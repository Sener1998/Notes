******************************************************************************************
******************************************************************************************
---下文有这两个系统函数的详解---
iverilog+gtkwave需要加入如下代码
	//指定VCD文件的名字为counter_tb.vcd，仿真信息将记录到此文件
	//指定层次数为0，则counter_tb模块及其下面各层次的所有信号将被记录
	initial begin  
		$dumpfile("counter_tb.vcd");
		$dumpvars(0, counter_tb);	
	end

结束仿真
	always begin
		#10;
		if ($time >= 1000) begin
		$finish;
		end
	end
******************************************************************************************
******************************************************************************************
$readmemb("E:/study/verilog/single_cycle/data/cpu.txt",memory);

$readmenb和$readmenh中的地址是绝对地址
文件中的空白字符视作分割，不会读取其他的数据
@4 10000100	//是指定004的位置存储10000100，即memory[4]中

@5 		//以直至5开始，从memory[5]开始
 11001000
 00000000
 111111111


（1）$readmemb("<数据文件名>",<存储器名>);

（2）$readmemb("<数据文件名>",<存储器名>,<起始地址>);

（3）$readmemb("<数据文件名>",<存储器名>,<起始地址>,<终止地址>);

（4）$readmemh("<数据文件名>",<存储器名>);

（5）$readmemh("<数据文件名>",<存储器名>,<起始地址>);

（6）$readmemh("<数据文件名>",<存储器名>,<起始地址>,<终止地址>);
******************************************************************************************
******************************************************************************************
verilog HDL中wire和reg的区别

wire表示直通，即输入有变化，输出马上无条件地反映（如与、非门的简单连接）。

reg表示一定要有触发，输出才会反映输入的状态。

reg相当于存储单元，wire相当于物理连线。reg表示一定要有触发，没有输入的时候可以保持原来的值，但不直接实际的硬件电路对应。

      两者的区别是：寄存器型数据保持最后一次的赋值，而线型数据需要持续的驱动。wire使用在连续赋值语句中，而reg使用在过程赋值语句（initial ，always）中。wire若无驱动器连接，其值为z，reg默认初始值为不定值 x 。

      在连续赋值语句中，表达式右侧的计算结果可以立即更新表达式的左侧。在理解上，相当于一个逻辑之后直接连了一条线，这个逻辑对应于表达式的右侧，而这条线就对应于wire。在过程赋值语句中，表达式右侧的计算结果在某种条件的触发下放到一个变量当中，而这个变量可以声明成reg类型的。根据触发条件的不同，过程赋值语句可以建模不同的硬件结构：如果这个条件是时钟的上升沿或下降沿，那么这个硬件模型就是一个触发器；如果这个条件是某一信号的高电平或低电平，那么这个硬件模型就是一个锁存器；如果这个条件是赋值语句右侧任意操作数的变化，那么这个硬件模型就是一个组合逻辑。

      对组合逻辑输出变量，可以直接用assign。即如果不指定为reg类型，那么就默认为1位wire类型，故无需指定1位wire类型的变量。当然专门指定出wire类型，可能是多位或为使程序易读。wire只能被assign连续赋值，reg只能在initial和always中赋值。

      输入端口可以由wire/reg驱动，但输入端口只能是wire；输出端口可以是wire/reg类型，输出端口只能驱动wire；若输出端口在过程块中赋值则为reg型，若在过程块外赋值则为net型（wire/tri）。用关键词inout声明一个双向端口, inout端口不能声明为reg类型，只能是wire类0型。

      默认信号是wire类型，reg类型要申明。这里所说的默认是指输出信号申明成output时为wire。如果是模块内部信号，必须申明成wire或者reg.

      对于always语句而言，赋值要申明成reg，连续赋值assign的时候要用wire。

模块调用时 信号类型确定方法总结如下：

•信号可以分为端口信号和内部信号。出现在端口列表中的信号是端口信号，其它的信号为内部信号。

•对于端口信号，输入端口只能是net类型。输出端口可以是net类型，也可以是register类型。若输出端口在过程块中赋值则为register类型；若在过程块外赋值(包括实例化语句），则为net类型。

•内部信号类型与输出端口相同，可以是net或register类型。判断方法也与输出端口相同。若在过程块中赋值，则为register类型；若在过程块外赋值，则为net类型。

•若信号既需要在过程块中赋值，又需要在过程块外赋值。这种情况是有可能出现的，如决断信号。这时需要一个中间信号转换。

下面所列是常出的错误及相应的错误信息(error message)

•用过程语句给一个net类型的或忘记声明类型的信号赋值。

           信息：illegal …… assignment.

•将实例的输出连接到声明为register类型的信号上。

           信息：<name> has illegal output port specification.

•将模块的输入信号声明为register类型。

           信息：incompatible declaration, <signal name> ……


wire V.S. reg
wire(组合逻辑)

    wire用来连接模块实例化的输入和输出端口；
    wire用作实际模块声明中输入和输出；
    wire 元素必须由某些东西驱动，并且在没有被驱动的情况下，无法存储值；
    wire 元素不能用在 always模块中 = 或者 <= 的左边；
    wire元素是assign语句左侧 唯一的合法类型；
    wire 元素是在基于Verilog的设计中连接两片的无状态方式;
    wire 只能用在 组合逻辑；

// wire 的一些正确使用
        wire A,B,C,D,E ; //1-bit wide
        wire [8:0] Wide; //9-bit
        assign A= B & C;
        always @(B or C) 
        begin
         I=B | C;
        end
        mymodule mymodule_instance(.In(D),Out(E));

reg(组合和时序逻辑)
reg 和 wire类似，但它可以用来存储信息（状态），就像寄存器

    reg可以连接到模块实例化的输入端口；
    reg 不能连接到模块实例化的输出端口；
    reg 可以用作实际模块声明中的输出；
    reg 不能 用作实际模块声明中的输入；
    reg是always 模块中 = 或者 <= 左侧的唯一正确类型；
    reg是initial模块中 = 左侧唯一的合法类型；
    reg**不能用在assign的左边**；
    reg 当与always @（posedge Clock）块结合使用时，reg可用于创建寄存器。

//reg一些合法使用
wire A,B;
reg I,J,K;  // 1-bit
reg [8:0] Wide; // 9-bit
always @(A or B) begin
    I=A | B; // using a reg as the left - hand side of an always

initial begin // using a reg in an initial block
    J=1'b1;
    #1
    J=1'b0;
end

always @(posedge Clock) begin
// using a reg to create a positive -edge - triggered register
    K<=I;
end

什么时候wire 和reg 可以互换？

    两者都可以出现在assign语句和 always 模块中=或<=的右侧;
    两者都可以连接到模块实例的输入端口;
******************************************************************************************
******************************************************************************************
//信号clk只要发生变化，就执行q<=d，双边沿D触发器模型
always @(clk) q <= d ;                
//在信号clk上升沿时刻，执行q<=d，正边沿D触发器模型
always @(posedge clk) q <= d ;  
//在信号clk下降沿时刻，执行q<=d，负边沿D触发器模型
always @(negedge clk) q <= d ;
//立刻计算d的值，并在clk上升沿时刻赋值给q，不推荐这种写法
q = @(posedge clk) d ;  

命名事件控制

用户可以声明 event（事件）类型的变量，并触发该变量来识别该事件是否发生。命名事件用关键字 event 来声明，触发信号用 -> 表示。例如：
实例
event     start_receiving ;
always @( posedge clk_samp) begin
        -> start_receiving ;       //采样时钟上升沿作为时间触发时刻
end
 
always @(start_receiving) begin
    data_buf = {data_if[0], data_if[1]} ; //触发时刻，对多维数据整合
end
******************************************************************************************
******************************************************************************************
命名块

我们可以给块语句结构命名。

命名的块中可以声明局部变量，通过层次名引用的方法对变量进行访问。

仿真代码如下:
实例
`timescale 1ns/1ns
 
module test;
 
    initial begin: runoob   //命名模块名字为runoob，分号不能少
        integer    i ;       //此变量可以通过test.runoob.i 被其他模块使用
        i = 0 ;
        forever begin
            #10 i = i + 10 ;      
        end
    end
 
    reg stop_flag ;
    initial stop_flag = 1'b0 ;
    always begin : detect_stop
        if ( test.runoob.i == 100) begin //i累加10次，即100ns时停止仿真
            $display("Now you can stop the simulation!!!");
            stop_flag = 1'b1 ;
        end
        #10 ;
    end
 
endmodule
******************************************************************************************
******************************************************************************************
“不可综合”(not synthesize)的意思是在硬件电路层面是不能实现的或很难实现，在verilogHDL中只能用来仿真用，不能在最终的程序中使用。
******************************************************************************************
******************************************************************************************
1)系统任务:$monitor
 
格式：
$monitor(p1,p2,p3...pn);
$monitor;
$monitoron;
$monitoroff;
任务$monitor提供了监控输出列表中的表达式或变量值的功能。其参数列表中输出格式控制字符串和输出列表的规则和$display一样。当启动一个带有一个或多个参数的$monitor时，仿真器则建立一个处理机制，使得每当参数列表中变量或者表达式的值发生变化是，整个参数列表中变量或者表达式的值都将输出显示。如果同一时刻，两个或多个参数的值发生变化，则该时刻只输出一次。在$monitor中，参数可以是$time系统函数。这样参数列表中变量或表达式的值同时发生变化的时刻可以通过表明同一时刻的多行显示出来。
如： $monitor($time,,"tex=%b rex=%b",tex,rex);     //注意这里的，，代表空参数，空参数在输出时显示为空格。
$monitor和$display的不同之处在于$monitor往往直接用在initial语句块中，只要不调用$monitoroff，$monitor便不断的对所设定的信号进行监视。$monitor不能在always块中调用。
再多模块的调试情况下，每一个模块都会默认调用$monitor语句，但是仿真器只能执行一个$monitor语句，因此程序会报错，这是需要$monitoron和$monitoroff语句，这样可以使得各个模块分开调用$monitor函数。
 
2)时间度量系统函数$time
 
在Verilog HDL中有两类型的时间系统函数，$time和$realtime。用这两个系统用函数可以的大当前的仿真时间。
$time可以返回一个64位的整数来表示当前仿真时刻值，该时刻是以模块的仿真时间尺度位基准的。
$realtime返回的时间数字是一个实型数。该数也是以时间尺度为基准的。
 
`timescale 10ns/1ns
module test;
  reg set;
  parameter p=1.6;
  initial
    begin
     $monitor($time,,"set=",set);
     #p  set=0;
     #p  set=1;
    end
endmodule
输出结果为：
 0 set=x
 2 set=0
 3 set=3
在这个例子中，模块test想在时间为16ns是设置寄存器set的值为0，在32ns时设置寄存器的set为1。但是由$time疾苦的set变化时刻却和预想的不一样，这是由下面两个原因引起的。
1)$time显示时刻受时间尺度的影响。这里时间尺度为10ns，故16ns和32ns是对应输出的数字为1.6和3.2。
2)$time总是输出整数，所以在将经过尺度比例变换的数字输出时，要先进行取整，1.6和3.2分别取整为1和3.2.
3)如果将上述例子中的$time替换成$realtime，那么输出的数字将变为1.6和3.2.
 
3)系统任务$readmemb $readmemh
在Verilog中有两个系统任务$readmemb和$readmemh，并用来从文件中读取数据到存储器中。这两个系统任务可以在仿真的任何时刻都被执行使用。
(1)$readmemb("<数据文件名>",<存储器名>)；
(2)$readmemb("<数据文件名>",<存储器名>,<起始地址>)；
(3)$readmemb("<数据文件名>",<存储器名>,<起始地址>，<结束地址>)；
(4)$readmemh("<数据文件名>",<存储器名>)；
(5)$readmemh("<数据文件名>",<存储器名>,<起始地址>)；
(6)$readmemh("<数据文件名>",<存储器名>,<起始地址>，<结束地址>)；
在这两个系统函数中，被读取的数据文件的内容只能包括：空白字符（空格换行和制表格） 注释行（//和/**/） 二进制和十六进制数字。当地址出现在数据文件中时，其格式为@FF...F。
复制代码

1 module test；
2   reg [0:7]memory[0:7];   //声明8个8位的存储单元
3    integer i;
4    initial
5      $readmemb("init.dat",memory);
6      for(i=0;i<8;i=i+1)
7        $display("memory[%d]=%b",i,memory[i]);
8    end
9 endmodule

复制代码
 如果文件中的内容为：
@002
11111111 00000000
01010101 10101010
@006
1111xxxx 00001111
则测试结果为:
memory[0]=xxxxxxxx
memory[1]=xxxxxxxx
memory[2]=11111111
memory[3]=00000000
memory[4]=01010101
memory[5]=10101010
memory[6]=1111xxxx
memory[7]=00001111
在上面6种系统任务格式，需补充说明一下几点：
(1)如果系统任务和数据文件都没有说明地址。则从默认的存储器地址开始写入数据，直至数据写完或者存储器存满。
(2)如果系统任务说明了起始地址，没有说明结束地址，则数据从起始地址开始存放，直至存储器的结束地址为止。
(3)如果系统任务说明了起始地址和结束地址。那么久按章任务说明中的地址进行存储，不考虑存储器的默认起始地址。
(4)如果系统任务和数据文件都说明了地址。那么数据文件中的地址说明必须包含在任务地址说明语句中，否则将出现错误信息，并且停止存储。
(5)如果数据文件中的数据个数和系统任务中起始地址和结束地址暗示的数据个数不同，也会报错。
 
4)系统任务$finish $stop
 
格式：
$finish;
$finish(n);
系统任务$finish的作用是退出仿真器，返回主操作系统，也就是结束仿真过程。$finish可以带承诺书，根据参数的值输出不同的特征信息。如果不带参数，默认其值为1；
0 不输出任何信息。
1 输出当前的仿真时间和位置；
2 输出当前的仿真时间、位置和仿真过程中所用memory和CPU的时间统计。
 
格式:
$stop;
$stop(n);
$stop任务的作用是将EDA工具设置为暂停模式，在仿真环境下给出一个交互式的命令，将控制权交给用户。参数值越大，输出信息越多。
 
5)系统任务$random
 
这个系统函数提供了一个产生随机数的手段。当函数被调用时返回一个32位的随机数。这是一个带符号的整型数。
$random的一般用法是：$random%b,其中b>0.他给出了一个范围在（-b+1）：（b-1）中的随机数。下面给出例子：
reg [23:0]rand;
rand=$random%60;            //生成-59~59之间的随机数
rand={$random}%60;        //生成0~59之间的随机数
******************************************************************************************
******************************************************************************************
// R:  [31:25]funct7        |[24:20]rs2 |[19:15]rs1 |[14:12]funct3  |[11:7]rd           |[6:0]opcode
// I:  [31:20]im[11:0]                  |[19:15]rs1 |[14:12]funct3  |[11:7]im[4:0]      |[6:0]opcode
// S:  [31:25]im[11:5]      |[24:20]rs2 |[19:15]rs1 |[14:12]funct3  |[11:7]rd           |[6:0]opcode
// SB: [31:25]im[12,10:5]   |[24:20]rs2 |[19:15]rs1 |[14:12]funct3  |[11:7]im[4:1,11]   |[6:0]opcode
******************************************************************************************
******************************************************************************************
$display(" ", `__FILE__, `__LINE__);
在打印信息时会显示该命令的所在文件的所在行
******************************************************************************************
******************************************************************************************
 verilog的$dumpfile和$dumpvar系统任务详解

$dumpfile和$dumpvar是verilog语言中的两个系统任务，可以调用这两个系统任务来创建和将指定信息导入VCD文件. 
什么是VCD文件?VCD文件是在对设计进行的仿真过程中，记录各种信号取值变化情况的信息记录文件。EDA工具通过读取VCD格式的文件，显示图形化的仿真波形，所以，可以把VCD文件简单地视为波形记录文件.)下面分别描述它们的用法并

举例说明之。

$dumpfile系统任务：为所要创建的VCD文件指定文件名。
举例（"//"符号后的内容为注释文字）：
initial
  $dumpfile ("myfile.dump");   //指定VCD文件的名字为myfile.dump，仿真信息将记录到此文件

$dumpvar系统任务：指定需要记录到VCD文件中的信号，可以指定某一模块层次上的所有信号，也可以单独指定某一个信号。
典型语法为$dumpvar(level, module_name); 参数level为一个整数，用于指定层次数，参数module则指定要记录的模块。整句的意思就是，对于指定的模块，包括其下各个层次(层次数由level指定)的信号，都需要记录到VCD文件中去。
举例：
initial
  $dumpvar (0, top);     //指定层次数为0，则top模块及其下面各层次的所有信号将被记录

initial
  $dumpvar (1, top);     //记录模块实例top以下一层的信号
                         //层次数为1，即记录top模块这一层次的信号
                         //对于top模块中调用的更深层次的模块实例，则不记录其信号变化

initial
  $dumpvar (2, top);     //记录模块实例top以下两层的信号
                         //即top模块及其下一层的信号将被记录

假设模块top中包含有子模块module1，而我们希望记录top.module1模块以下两层的信号，则语法举例如下：
initial
  $dumpvar (2, top.module1);  //模块实例top.module1及其下一层的信号将被记录

假设模块top包含信号signal1和signal2(注意是变量而不是子模块), 如我们希望只记录这两个信号，则语法举例如下：
initial
  $dumpvar (0, top.signal1, top.signal2);  //虽然指定了层次数，但层次数是不影响单独指定的信号的
                                           //即指定层次数和单独指定的信号无关

我们甚至可以在同一个$dumpvar的调用中，同时指定某些层次上的所有信号和某个单独的信号，假设模块top包含信号signal1，同时包含有子模块module1，如果我们不但希望记录signal1这个独立的信号，而且还希望记录子模块
module1以下三层的所有信号，则语法举例如下：
initial
  $dumpvar (3, top.signal1, top.module1);  //指定层次数和单独指定的信号无关
                                           //所以层次数3只作用于模块top.module1, 而与信号top.signal1无关 

上面这个例子和下面的语句是等效的：
initial
begin
  $dumpvar (0, top.signal1);
  $dumpvar (3, top.module1);
end

$dumpvar的特别用法(不带任何参数)：
initial
  $dumpvar;        //无参数，表示设计中的所有信号都将被记录

最后，我们将$dumpfile和$dumpvar这两个系统任务的使用方法在下面的例子中综合说明，假设我们有一个设计实例，名为 i_design，此设计中包含模块module1，模块module1下面还有很多层次，我们希望对这个设计进行仿真，并将仿真过程中模块module1及其以下所有层次中所有信号的变化情况，记录存储到名为mydesign.dump的VCD文件中去，
则例示如下：
initial
begin
  $dumpfile ("mydesign.dump");     //指定VCD文件名为mydesign.dump
  $dumpvar (0, i_design.module1);  //记录i_design.module1模块及其下面层次中所有模块的所有信号
end
------------------------------------------------------------------------------------------
Verilog提供一系列系统任务用于记录信号值变化，常见的格式有vcd,fsdb等。

$dumpfile("file. dump"); 打开一个VCD数据库用于记录
$dumpvars(level,start_module); 要记录的信号，level=0表示记录所有
$dumpflush; 将VCD数据保存到磁盘  不明白
$dumpoff; 停止记录
$dumpon; 重新开始记录
$dumplimit(); 限制VCD文件的大小(以字节为单位）
$dumpall; 记录所有指定的信号值

举例：
$dumpvars; // Dump所有层次的信号
$dumpvars (1, top); // Dump top模块中的所有信号
$dumpvars (2, top. u1); // Dump实例top. u1及其下一层的信号
$dumpvars (0, top. u2, top. u1. u13. q); // Dump top.u2及其以下所有信号，以及信号top. u1. u13. q。
$dumpvars (3, top. u2, top. u1); // Dump top. u1和top. u2及其下两层中的所有信号。
******************************************************************************************
******************************************************************************************
写代码时要时刻注意不能有一丝不确定
例子：
x->0算不算下降沿？
错误写法：
initial begin
  reset = 0;
  clock = 0;
  forever #50 clock = ~clock;
end
always @(negedge reset)
  $display("May to may not display at time zero.");
正确写法：
initial begin
  reset = 1;
  #10 reset = 0;  //先拉高再拉低，因为x->1肯定不是下降沿且1->0一定是下降沿
  clock = 0;
  forever #50 clock = ~clock;
end
always @(negedge reset)
  $display("Will not display at time zero.");
******************************************************************************************
******************************************************************************************
除了双向口的情况，不要使用多驱动源
在两个always里对同一个寄存器赋值就是多驱动源
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************