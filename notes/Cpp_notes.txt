******************************************************************************************
******************************************************************************************
https://en.cppreference.com
https://www.cplusplus.com
******************************************************************************************
******************************************************************************************

内存管理注意事项
------------------------------------------------------------------------------------------
	在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。
　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。
　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。
　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。
　　但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。
　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。
------------------------------------------------------------------------------------------
对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。
------------------------------------------------------------------------------------------
assert是一个宏，包含在assert.h头文件中。命令assert(NULL!=p)的逻辑值为假时，程序终止运行，并提示错误；如果逻辑值为真，则继续运行后面的代码。assert这个宏仅仅在Debug版本上起作用，在Release版本中被编译器完成优化掉。（所以assert这个宏只是帮助我们调试代码的，它的作用是：让用户在调试函数的时候把错误排除掉，而不是等待Release之后。assert可以帮助定位错误，而不是排除错误）
------------------------------------------------------------------------------------------
注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。
------------------------------------------------------------------------------------------
用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡
------------------------------------------------------------------------------------------
“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：
（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如
（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。
（3）指针操作超越了变量的作用域范围。这种情况让人防不胜防
------------------------------------------------------------------------------------------
如果用new创建对象数组，那么只能使用对象的无参数构造函数
------------------------------------------------------------------------------------------

未完待续，太难理解了

******************************************************************************************
******************************************************************************************
C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 

1 是个构造；2 是个默认且隐含的类型转换操作符。

所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。
这样看起来好象很酷， 很方便。 但在某些情况下， 却违背了程序员的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。 
******************************************************************************************
******************************************************************************************
C++ Primer 中指出，size_type是一种类型，确保能够保存可能存在的最大向量中的所有元素，这句话究竟怎么理解？
答：
所谓 size_type 就是这个“vector 的 size 的类型”。size就是指vector有多少个元素，这个“多少个”也是个整型值，它的类型就是 size_type。
举个具体的例子：
假如有个vector，你调用size()来得到它有多少个元素，你要把这个值存在一个变量里，那么这个变量该声明为什么类型呢？int 型吗？ 万一这个vector的元素数超过了 int 的范围呢？ 要不就用 long？ 万一也不够用呢？？
所以，我们把 size_type 作为这个 size 值的类型，你只要声明一个 size_type 类型的变量就能存下“元素个数”的值。顺便一提，在 C 语言中 size_t 指的是系统中最大的整型类型，一般在前述情况下都是使用 size_t 类型的。size_t不是容器概念，而size_type是容器概念，没有容器不能使用。size_type和size_t没有本质区别。
******************************************************************************************
******************************************************************************************
cosnt char* name = R"haksdhc()dcs
asdd
asds"
字符串前加R表示字符串中不使用转义字符


编码相关：
const char* name = u8"Sener";		//普通的字符串，utf-8，1个字符1个字节
const wchar_t* name1 = L"Sener";	//宽字符的字符串，1个字符不一定几个字节，反正大于1个（windows下是2个，linux是4个）
const char16_t* name2 = u"Sener";	//utf-16，1个字符2个字节
const char32_t* name3 = U"Sener";	//utf-32，1个字符4个字节
不建议用wchar_t，有需求的话直接用char16_t或char32_t就好
******************************************************************************************
******************************************************************************************
第一种const用法，用于修饰变量类型

int* p = new int;		//表示最普通的int类型指针，p指向的内容可以修改，p指向的对象也可以更换
const int* p = new int;	//常量指针，p指向的内容不能修改（换个说法，不能通过p来修改这块内存），p指向的对象可以更换
int const* p = new int;	//常量指针，和上边那个一样，只要const在*前面都一样
int* const p = new int;	//指针常量，p指向的内容可以修改，但是p指向的对象不能更换（换个说法，p的值不能改变）
const int* const p = new int; //指向常量的常量指针，啥都不能改
------------------------------------------------------------------------------------------
第二种const用法，用于修饰函数（不是函数的返回值类型，就是函数的类型）

class Entity
{
private:
    int m_X, m_Y;
	mutable int var;
public:
    int GetX() const
    {
        return m_X;
	}
	int GetY()
    {
        return m_Y;
	}
}
这里的const表示本函数保证不修改实际类，只对类进行读操作
所以对于const Entity e，可以执行e.GetX()，而不能执行e.GetY()，因为后者没有做出承诺
当然，如果仅仅只是这样就太小瞧C++了，因为作为一个资深渣男，不遵守承诺也不是什么大不了的事
所以对于使用mutable修饰的var，还是可以在GetX里面修改的，比如GetX可以这么写：
int GetX() const
{
    var = 10;
    return m_X;
}
******************************************************************************************
******************************************************************************************
mutable用法，一种是和const一起作为渣男利器存在，另一种是搭配lamda

首先看这种情况，此时会提示x++的x必须是可修改的左值
因为[=]表示按值捕获，在函数体里面创建了个常数（右值），让它叫x并等于捕获到的10，所以不能修改
int x = 10;
auto f = [=]()
{
	x++;
	std::cout << x << std::endl;
};


改成这样，就可以了
int x = 10;
auto f = [=]() mutable
{
	x++;
	std::cout << x << std::endl;
};

只是为了代码简洁，因为不用mutable也可以实现相同的操作
int x = 10;
auto f = [=]()
{
	int y = x；
	y++；
	std::cout << y << std::endl;
};
******************************************************************************************
******************************************************************************************
lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。
lambda表达式的语法形式可简单归纳如下：

[ capture ] ( params ) opt -> ret { body; };
其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。

因此，一个完整的 lambda 表达式看起来像这样：
auto f = [](int a) -> int { return a + 1; };
std::cout << f(1) << std::endl;  // 输出: 2
可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。

在C++11中，lambda表达式的返回值是通过前面介绍的《C++返回值类型后置》语法来定义的。
其实很多时候，lambda表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：
auto f = [](int a){ return a + 1; };
这样编译器就会根据 return 语句自动推导出返回值类型。

需要注意的是，初始化列表不能用于返回值的自动推导：
auto x1 = [](int i){ return i; };  // OK: return type is int
auto x2 = [](){ return { 1, 2 }; };  // error: 无法推导出返回值类型
这时我们需要显式给出具体的返回值类型。

另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：
auto f1 = [](){ return 1; };
auto f2 = []{ return 1; };  // 省略空参数表
------------------------------------------------------------------------------------------
使用 lambda 表达式捕获列表
lambda 表达式还可以通过捕获列表捕获一定范围内的变量：

    [] 不捕获任何变量。
    [&] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
    [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。
    [=，&foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
    [bar] 按值捕获 bar 变量，同时不捕获其他变量。
    [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。
******************************************************************************************
******************************************************************************************
成员列表要按声明顺序初始化，否则会产生些不必要的依赖
class Entity
{
private:
	int m_Score;
	srd::string m_Name;
public:
	Entity() : m_Score(0), m_Name("Unknown") {}
}
******************************************************************************************
******************************************************************************************
智能指针
不需要自己管理内存，也就是说不用记着new完后要delete
有三种：unique_ptr、shared_ptr、weak_ptr
unique_ptr：优先使用这个，因为这个开销小，仅仅只是new完delete，也就是说指向某一实体的不同的unique_ptr有一个失效，实体就delete了，所以不允许复制unique_ptr
shared_ptr：多了记数功能，只有在指向某一实体的所有shared_ptr都失效的情况下，实体才会delete
weak_ptr：搭配shared_ptr使用，不参与计数，也就是说实体的存无跟它没有半毛钱关系
******************************************************************************************
******************************************************************************************
浅拷贝、深拷贝
如果一个类里面有指针，那么直接复制的话仅仅只是把指针存储的那个地址复制了一份，指针指向的内存还是那个，这叫浅拷贝
默认的的复制构造函数实现的是浅拷贝，如果想把指针指向的内存中的数据也复制一份就要重写复制构造函数，重新new并且memcpy

例：
class Entity
{
private:
	int* m_p;
public:
	Entity() = delete;
	Entity(const int& data)
	{
		m_p = new int(data);
	}
	Entity(const Entity& other) //重写的复制构造函数，默认的是这样的  Entity(const Entity& other):m_p(other.m_p){}
	{
		m_p = new int(*(other.m_p));
	}
	~Entity() { delete m_p; }
};
******************************************************************************************
******************************************************************************************
得到不确定大小和类型的std::array的大小

std::array<int, 5> arr;
std::array<int, 7> arr2;

问题在于std::array的大小是类型确定的，但是不知道类型就没法传入函数比如下面这个
int PrintSize(std::array<int, 5> arr)
{
	return arr.size();
}
这个函数只能允许传入arr，但是我都知道是5了我还调用个屁

所以用模板来搞
template <class T>
int PrintSize(T arr)
{
	return arr.size();
}
正常来讲，应该这么调用PrintSize<std::array<int, 5>>(arr)，但是这么调用就没意义了
我们直接这么来PrintSize(arr)，编译器会自动识别出来arr的类型，然后生成一个对应类型的PrintSize

这里巧妙的是利用编译器可以自动识别template函数传入的变量类型
******************************************************************************************
******************************************************************************************
简单测试用的定时器
#include <chrono>
struct Timer{
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<float, std::ratio<1,1>> duration; // 这是秒，毫秒就用std::ratio<1,1000>

	Timer() : duration(0) {
		start = std::chrono::high_resolution_clock::now();
	}
	~Timer() {
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		std::cout << duration.count() << std::endl;
	}
};
把这个结构体类型的实例随便丢在一个函数里，这个函数执行完后就输出执行的时间了，非常优雅

例：
void TestFunc()
{
	Timer timer;
	for (int i = 0; i < 100; i++) {
		std::cout << "Hello World!" << std::endl;
	}
}
******************************************************************************************
******************************************************************************************
类型双关，把一个地址的数据原封不动转成别的类型
int a = 5;
double&  value = *(double*)&a;
******************************************************************************************
******************************************************************************************
首先要说明的是使用C风格的类型转换可以满足所有的需求，使用C++的并不能引入新的特性

C++风格的类型转换
详细见https://cplusplus.com/doc/tutorial/typecasting/

1. dynamic_cast
带安全性检测的类型转换
不可以随便搞，但是要保证开启 Run-Time Type Information(RTTI) 功能

2. static_cast
不带安全性检测的类型转换
可以随便搞，出问题算程序员的

3. reinterpret_cast
类似于类型双关，直接把对应内存里二进制数据拷贝出来当作转换后的类型

4. const_cast
可以将带const的类型转换成不带const的，并不意味着原来带const的不带了，而是转换后的那个不带了
******************************************************************************************
******************************************************************************************
（C++17的新特性）
多返回值的函数可以使用std::tuple和auto来实现
std::tuple<std::string, int> test()
{
	return { "haha", 5 };
}

auto [name, age] = test();
******************************************************************************************
******************************************************************************************
（C++17的新特性）
对于不确定是否有返回值的函数可以这么处理
std::optional<std::string> GetString(bool flag)
{
	if (flag)
	{
		return "haha";
	}
	return {};
}

auto str = GetString(true);
std::string s1 = str.value_or("fuck");
std::cout << str.value() << "\n";

str = GetString(false);
std::string s2 = str.value_or("fuck");
std::cout << s2 << "\n";

s1收到了"haha"
s2没有收到"haha"，所以是默认值"fuck"
******************************************************************************************
******************************************************************************************
（C++17的新特性）
不确定v的类型具体是啥可以这么搞，用的时候判断一下是什么类型
std::variant<int, double> v;
v = 210.0;
if (auto p = std::get_if<int>(&v))
{
	std::cout << "int " << *p << "\n";
}
else
{
	std::cout << "double " << std::get<double>(v) << "\n";
}
******************************************************************************************
******************************************************************************************
重载<<以输出自定义类型数据
static std::ostream& operator<<(std::ostream& out, const std::array<float, 6>& data) {
	for (auto i : data) {
		out << i << ' ';
	}
	return out;
}
******************************************************************************************
******************************************************************************************
构造函数大全，应有尽有

class Name {
private:
	char* m_Name;
public:
	Name() = delete;
	Name(const char* name) {
		const int len = strlen(name);
		m_Name = new char[len + 1];
		strcpy_s(m_Name, len + 1, name);
		std::cout << "Copy\n";
	}
	Name(const Name& other) {
		const int len = strlen(other.m_Name);
		m_Name = new char[len + 1];
		strcpy_s(m_Name, len + 1, other.m_Name);
		std::cout << "Copy\n";
	}
	Name(Name&& other) noexcept {
		m_Name = other.m_Name;
		other.m_Name = nullptr;
		std::cout << "Move\n";
	}
	Name& operator=(Name& other) noexcept {
		const int len = strlen(other.m_Name);
		m_Name = new char[len + 1];
		strcpy_s(m_Name, len + 1, other.m_Name);
		std::cout << "Copy\n";
		return *this;
	}
	Name& operator=(Name&& other) noexcept {
		if (this != &other) {
			delete[] m_Name;
			m_Name = other.m_Name;
			other.m_Name = nullptr;
			std::cout << "Move\n";
		}
		return *this;
	}

	~Name() {
		delete[] m_Name;
		m_Name = nullptr;
		std::cout << "Destroy\n";
	}

	void Print() {
		if (m_Name != nullptr) {
			std::cout << m_Name << '\n';
		}
	}
};
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------