******************************************************************************************
******************************************************************************************
内存管理注意事项
------------------------------------------------------------------------------------------
	在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。
　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。
　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。
　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。
　　但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。
　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。
------------------------------------------------------------------------------------------
对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。
------------------------------------------------------------------------------------------
assert是一个宏，包含在assert.h头文件中。命令assert(NULL!=p)的逻辑值为假时，程序终止运行，并提示错误；如果逻辑值为真，则继续运行后面的代码。assert这个宏仅仅在Debug版本上起作用，在Release版本中被编译器完成优化掉。（所以assert这个宏只是帮助我们调试代码的，它的作用是：让用户在调试函数的时候把错误排除掉，而不是等待Release之后。assert可以帮助定位错误，而不是排除错误）
------------------------------------------------------------------------------------------
注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。
------------------------------------------------------------------------------------------
用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡
------------------------------------------------------------------------------------------
“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：
（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如
（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。
（3）指针操作超越了变量的作用域范围。这种情况让人防不胜防
------------------------------------------------------------------------------------------
如果用new创建对象数组，那么只能使用对象的无参数构造函数
------------------------------------------------------------------------------------------

未完待续，太难理解了

******************************************************************************************
******************************************************************************************
C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 

1 是个构造；2 是个默认且隐含的类型转换操作符。

所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。
这样看起来好象很酷， 很方便。 但在某些情况下， 却违背了程序员的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。 
******************************************************************************************
******************************************************************************************
C++ Primer 中指出，size_type是一种类型，确保能够保存可能存在的最大向量中的所有元素，这句话究竟怎么理解？
答：
所谓 size_type 就是这个“vector 的 size 的类型”。size就是指vector有多少个元素，这个“多少个”也是个整型值，它的类型就是 size_type。
举个具体的例子：
假如有个vector，你调用size()来得到它有多少个元素，你要把这个值存在一个变量里，那么这个变量该声明为什么类型呢？int 型吗？ 万一这个vector的元素数超过了 int 的范围呢？ 要不就用 long？ 万一也不够用呢？？
所以，我们把 size_type 作为这个 size 值的类型，你只要声明一个 size_type 类型的变量就能存下“元素个数”的值。顺便一提，在 C 语言中 size_t 指的是系统中最大的整型类型，一般在前述情况下都是使用 size_t 类型的。size_t不是容器概念，而size_type是容器概念，没有容器不能使用。size_type和size_t没有本质区别。
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
------------------------------------------------------------------------------------------