******************************************************************************************
******************************************************************************************
内存管理注意事项
------------------------------------------------------------------------------------------
	在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。
　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。
　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。
　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。
　　但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。
　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。
------------------------------------------------------------------------------------------
对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。
------------------------------------------------------------------------------------------
assert是一个宏，包含在assert.h头文件中。命令assert(NULL!=p)的逻辑值为假时，程序终止运行，并提示错误；如果逻辑值为真，则继续运行后面的代码。assert这个宏仅仅在Debug版本上起作用，在Release版本中被编译器完成优化掉。（所以assert这个宏只是帮助我们调试代码的，它的作用是：让用户在调试函数的时候把错误排除掉，而不是等待Release之后。assert可以帮助定位错误，而不是排除错误）
------------------------------------------------------------------------------------------
注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。
------------------------------------------------------------------------------------------
用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡
------------------------------------------------------------------------------------------
“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：
（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如
（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。
（3）指针操作超越了变量的作用域范围。这种情况让人防不胜防
------------------------------------------------------------------------------------------
如果用new创建对象数组，那么只能使用对象的无参数构造函数
------------------------------------------------------------------------------------------

未完待续，太难理解了

******************************************************************************************
******************************************************************************************
C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 

1 是个构造；2 是个默认且隐含的类型转换操作符。

所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。
这样看起来好象很酷， 很方便。 但在某些情况下， 却违背了程序员的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。 
******************************************************************************************
******************************************************************************************
C++ Primer 中指出，size_type是一种类型，确保能够保存可能存在的最大向量中的所有元素，这句话究竟怎么理解？
答：
所谓 size_type 就是这个“vector 的 size 的类型”。size就是指vector有多少个元素，这个“多少个”也是个整型值，它的类型就是 size_type。
举个具体的例子：
假如有个vector，你调用size()来得到它有多少个元素，你要把这个值存在一个变量里，那么这个变量该声明为什么类型呢？int 型吗？ 万一这个vector的元素数超过了 int 的范围呢？ 要不就用 long？ 万一也不够用呢？？
所以，我们把 size_type 作为这个 size 值的类型，你只要声明一个 size_type 类型的变量就能存下“元素个数”的值。顺便一提，在 C 语言中 size_t 指的是系统中最大的整型类型，一般在前述情况下都是使用 size_t 类型的。size_t不是容器概念，而size_type是容器概念，没有容器不能使用。size_type和size_t没有本质区别。
******************************************************************************************
******************************************************************************************
cosnt char* name = R"haksdhc()dcs
asdd
asds"
字符串前加R表示字符串中不使用转义字符


编码相关：
const char* name = u8"Sener";		//普通的字符串，utf-8，1个字符1个字节
const wchar_t* name1 = L"Sener";	//宽字符的字符串，1个字符不一定几个字节，反正大于1个（windows下是2个，linux是4个）
const char16_t* name2 = u"Sener";	//utf-16，1个字符2个字节
const char32_t* name3 = U"Sener";	//utf-32，1个字符4个字节
不建议用wchar_t，有需求的话直接用char16_t或char32_t就好
******************************************************************************************
******************************************************************************************
第一种const用法，用于修饰变量类型

int* p = new int;		//表示最普通的int类型指针，p指向的内容可以修改，p指向的对象也可以更换
const int* p = new int;	//常量指针，p指向的内容不能修改（换个说法，不能通过p来修改这块内存），p指向的对象可以更换
int const* p = new int;	//常量指针，和上边那个一样，只要const在*前面都一样
int* const p = new int;	//指针常量，p指向的内容可以修改，但是p指向的对象不能更换（换个说法，p的值不能改变）
const int* const p = new int; //指向常量的常量指针，啥都不能改
------------------------------------------------------------------------------------------
第二种const用法，用于修饰函数（不是函数的返回值类型，就是函数的类型）

class Entity
{
private:
    int m_X, m_Y;
	mutable int var;
public:
    int GetX() const
    {
        return m_X;
	}
	int GetY()
    {
        return m_Y;
	}
}
这里的const表示本函数保证不修改实际类，只对类进行读操作
所以对于const Entity e，可以执行e.GetX()，而不能执行e.GetY()，因为后者没有做出承诺
当然，如果仅仅只是这样就太小瞧C++了，因为作为一个资深渣男，不遵守承诺也不是什么大不了的事
所以对于使用mutable修饰的var，还是可以在GetX里面修改的，比如GetX可以这么写：
int GetX() const
{
    var = 10;
    return m_X;
}
******************************************************************************************
******************************************************************************************
mutable用法，一种是和const一起作为渣男利器存在，另一种是搭配lamda

首先看这种情况，此时会提示x++的x必须是可修改的左值
因为[=]表示按值捕获，在函数体里面创建了个常数（右值），让它叫x并等于捕获到的10，所以不能修改
int x = 10;
auto f = [=]()
{
	x++;
	std::cout << x << std::endl;
};


改成这样，就可以了
int x = 10;
auto f = [=]() mutable
{
	x++;
	std::cout << x << std::endl;
};

只是为了代码简洁，因为不用mutable也可以实现相同的操作
int x = 10;
auto f = [=]()
{
	int y = x；
	y++；
	std::cout << y << std::endl;
};
******************************************************************************************
******************************************************************************************
lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。
lambda表达式的语法形式可简单归纳如下：

[ capture ] ( params ) opt -> ret { body; };
其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。

因此，一个完整的 lambda 表达式看起来像这样：
auto f = [](int a) -> int { return a + 1; };
std::cout << f(1) << std::endl;  // 输出: 2
可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。

在C++11中，lambda表达式的返回值是通过前面介绍的《C++返回值类型后置》语法来定义的。
其实很多时候，lambda表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：
auto f = [](int a){ return a + 1; };
这样编译器就会根据 return 语句自动推导出返回值类型。

需要注意的是，初始化列表不能用于返回值的自动推导：
auto x1 = [](int i){ return i; };  // OK: return type is int
auto x2 = [](){ return { 1, 2 }; };  // error: 无法推导出返回值类型
这时我们需要显式给出具体的返回值类型。

另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：
auto f1 = [](){ return 1; };
auto f2 = []{ return 1; };  // 省略空参数表
------------------------------------------------------------------------------------------
使用 lambda 表达式捕获列表
lambda 表达式还可以通过捕获列表捕获一定范围内的变量：

    [] 不捕获任何变量。
    [&] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
    [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。
    [=，&foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
    [bar] 按值捕获 bar 变量，同时不捕获其他变量。
    [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。
******************************************************************************************
******************************************************************************************
成员列表要按声明顺序初始化，否则会产生些不必要的依赖
class Entity
{
private:
	int m_Score;
	srd::string m_Name;
public:
	Entity() : m_Score(0), m_Name("Unknown") {}
}
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------