******************************************************************************************
******************************************************************************************
makefile的执行步骤：
	1、读入所有的Makefile。
	2、读入被include的其它Makefile。
	3、初始化文件中的变量。
	4、推导隐晦规则，并分析所有规则。
	5、为所有的目标文件创建依赖关系链。
	6、根据依赖关系，决定哪些目标要重新生成。
	7、执行生成命令
******************************************************************************************
******************************************************************************************
wildcard:
	$(wildcard PATTERN...)
	在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”，它的用法是：$(wildcard PATTERN...) 。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。
------------------------------------------------------------------------------------------
patsubst:
	$(patsubst <pattern>,<replacement>,<text> )
	名称:模式字符串替换函数——patsubst。
	功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。
	这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。
	（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）
	返回：函数返回被替换过后的字符串。
------------------------------------------------------------------------------------------
notdir:
	$(notdir PATTERN...)
	去除所有的目录信息，SRC里的文件名列表将只有文件名。
------------------------------------------------------------------------------------------
建立一个简单的Makefile
src=$(wildcard *.c ./sub/*.c)
file=$(notdir $(src))
obj=$(patsubst %.c,%.o,$(src))
******************************************************************************************
******************************************************************************************
	*  匹配0个或者是任意个字符
	？ 匹配任意一个字符
	[] 我们可以指定匹配的字符放在 "[]" 中
------------------------------------------------------------------------------------------
还有一个和通配符 "*" 相类似的字符，这个字符是 "%"，也是匹配任意个字符，使用在我们的的规则当中。

test:test.o test1.o
    gcc -o $@ $^
%.o:%.c
    gcc -o $@ $^

 	"%.o" 把我们需要的所有的 ".o" 文件组合成为一个列表，从列表中挨个取出的每一个文件，"%" 表示取出来文件的文件名（不包含后缀），然后找到文件中和 "%"名称相同的 ".c" 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。
******************************************************************************************
******************************************************************************************
shell:
	$0 是脚本本身的名字
	$n 是传递给脚本或函数的参数。
		 n 是一个数字，表示第几个参数。例如,
		$1 是传递给该shell脚本的第一个参数
		$2 是传递给该shell脚本的第二个参数
	$# 是传给脚本的参数个数
	$@ 是传给脚本的所有参数的列表
	$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个
	$$ 是脚本运行的当前进程ID号
	$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误
------------------------------------------------------------------------------------------
makefile:
	$@ 表示目标文件
	$^ 表示所有的依赖文件
	$< 表示第一个依赖文件
	$? 表示比目标还要新的依赖文件列表
	
	$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是“foo.a(bar.o)”，那么，“$%”就是“bar.o”，“$@”就是“foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。
	
	$+ 这个变量很像“$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
	
	$* 这个变量表示目标模式中“%”及其之前的部分。如果目标是“dir/a.foo.b”，并且目标的模式是“a.%.b”，那么，“$*”的值就是“dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么“$*”也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么“$*”就是除了后缀的那一部分。例如：如果目标是“foo.c”，因为“.c”是make所能识别的后缀名，所以，“$*”的值就是“foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用“$*”，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么“$*”就是空值。
------------------------------------------------------------------------------------------
	$@ 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。
	$% 当目标文件是一个静态库文件时，代表静态库的一个成员名。
	$< 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。
	$? 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。
	$^ 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。
一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。
	$+ 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。
	$* 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录部分）。
------------------------------------------------------------------------------------------
	$(@D) 表示文件的目录部分（不包括斜杠）。如果 "$@" 表示的是 "dir/foo.o" 那么 "$(@D)" 表示的值就是 "dir"。如果 "$@" 不存在斜杠（文件在当前目录下），其值就是 "."。
	$(@F) 表示的是文件除目录外的部分（实际的文件名）。如果 "$@" 表示的是 "dir/foo.o"，那么 "$@F" 表示的值为 "foo.o"。
	$(*D)
	$(*F) 分别代表 "茎" 中的目录部分和文件名部分
	$(%D)
	$(%F) 当以 "archive(member)" 形式静态库为目标时，分别表示库文件成员 "member" 名中的目录部分和文件名部分。踏进对这种新型时的目标有效。
	$(<D)
	$(<F) 表示第一个依赖文件的目录部分和文件名部分。
	$(^D)
	$(^F) 分别表示所有依赖文件的目录部分和文件部分。
	$(+D)
	$(+F) 分别表示所有的依赖文件的目录部分和文件部分。
	$(?D)
	$(?F) 分别表示更新的依赖文件的目录部分和文件名部分。
******************************************************************************************
******************************************************************************************
简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
递归赋值 (  = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。
------------------------------------------------------------------------------------------
那makefile中“=”和“:=”的区别到底有什么区别？因为都是给变量赋值。从下面例子的执行结果来看，对于“=”符合make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。在下例中，y的值将会是 xyz android ，而不是 fuck android ；但是对于“:=”符合，表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值，所以h的值是fuck linux。本质是运算优先级的问题，先计算=右侧的表达式和对:=左侧的值赋值，之后再对=左侧的值赋值。
x = fuck
y = $(x) android   #"xyz android"
x = xyz
h  = fuck
i := $(h) linux    #"fuck linux"
h := hip
******************************************************************************************
******************************************************************************************
在 Makefile 中可以这样写：

VPATH := src
我们可以这样理解，把 src 的值赋值给变量 VPATH，所以在执行 make 的时候会从 src 目录下找我们需要的文件。

当存在多个路径的时候我们可以这样写：

VPATH := src car
VPATH := src:car

多个路径之间要使用空格或者是冒号隔开，表示在多个路径下搜索文件。搜索的顺序为我们书写时的顺序，拿上面的例子来说，我们应该先搜索 src 目录下的文件，再搜索 car 目录下的文件。

注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。
------------------------------------------------------------------------------------------
学习了 VPATH的使用，我们再来了解一下关键字搜索 vpath 的使用，这种搜索方式一般被称作选择性搜索。使用上的区别我们可以这样理解：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。
 
具体用法：
1) vpath PATTERN DIRECTORIES 
2) vpath PATTERN
3) vpath
( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )
------------------------------------------------------------------------------------------
这仅仅是对于makefile来说搜索目标和依赖文件的路径，但是对于命令行来说是无效的，也就是说
在执行g++或者gcc时不会自动从VPATH 或者vpath中自动搜索要包含的头文件等信息文件
此时要用到了 -I 或者--incude +路径

例如依赖是：
main.o:main.cpp hello.h
    g++ -c $< -Iinclude
这时候，g++会自动从include目录中搜索要包含的hello.h头文件
******************************************************************************************
******************************************************************************************
g++ -E main.cpp -o main.i    预处理
g++ -S main.i   -o main.s    编译
g++ -c main.s   -o main.o    汇编
g++    main.o   -o main      链接

-W -Wall  打开警告
******************************************************************************************
******************************************************************************************
这里讲的是预先设置的隐含规则。如果不明确的写下规则，那么make 就会自己寻找所需要的规则和命令。当然我们也可以使用 make 选项：-r或-n-builtin-rules选项来取消所有的预设值的隐含规则。当然即使是指定了“-r”的参数，某些隐含规则还是会生效。因为有很多的隐含规则都是使用了后缀名的规则来定义的，所以只要隐含规则中含有“后缀列表”那么隐含规则就会生效。默认的列表是：
.out、.a、.in、.o、.c、.cc、.C、.p、.f、.F、.r、.y、.l、.s、.S、.mod、.sym、.def、
.h、.info、.dvi、.tex、.texinfo、.texi、.txinfo、.w、.ch、.web、.sh、.elc、.el。
------------------------------------------------------------------------------------------
下面是一些常用的隐含规则：
	编译 C 程序
	编译 C++ 程序
	编译 Pascal 程序
	编译 Fortran/Ratfor 程序
	预处理 Fortran/Ratfor 程序
	编译 Modula-2 程序
	汇编和需要预处理的汇编程序
	链接单一的 object 文件
    Yacc C 程序
    Lex C 程序时的隐含规则
------------------------------------------------------------------------------------------
隐含规则中使用的变量可以分成两类：
	1.代表一个程序的名字。例如：“CC”代表了编译器的这个可执行程序。
	2.代表执行这个程序使用的参数.例如：变量“CFLAGS”。多个参数之间使用空格隔开。

下面我们来列举一下代表命令的变量，默认都是小写。
	AR：函数库打包程序，科创价静态库 .a 文档。
	AS：应用于汇编程序。
	CC：C 编译程序。
	CXX：C++编译程序。
	CO：从 RCS 中提取文件的程序。
	CPP：C程序的预处理器。
	FC：编译器和与处理函数 Fortran 源文件的编译器。
	GET：从CSSC 中提取文件程序。
	LEX：将Lex语言转变为 C 或 Ratfo 的程序。
	PC：Pascal 语言编译器。
	YACC：Yacc 文法分析器（针对于C语言）
	YACCR：Yacc 文法分析器。
******************************************************************************************
******************************************************************************************
ifeq 	判断参数是否不相等，相等为 true，不相等为 false。
ifneq 	判断参数是否不相等，不相等为 true，相等为 false。
ifdef 	判断是否有值，有值为 true，没有值为 false。
ifndef 	判断是否有值，没有值为 true，有值为 false。

条件判断的使用方式如下：
ifeq (ARG1, ARG2)
ifeq 'ARG1' 'ARG2'
ifeq "ARG1" "ARG2"
ifeq "ARG1" 'ARG2'
ifeq 'ARG1' "ARG2"

实例：
    libs_for_gcc= -lgnu
    normal_libs=
    foo:$(objects)
    ifeq($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
    else
        $(CC) -o foo $(objects) $(noemal_libs)
    endif
------------------------------------------------------------------------------------------
 ifdef 和 ifndef 
使用方式如下：
ifdef VARIABLE-NAME
它的主要功能是判断变量的值是不是为空，实例：
    bar =
    foo = $(bar)
    all:
    ifdef foo
        @echo yes
    else
        @echo  no
    endif
******************************************************************************************
******************************************************************************************
使用伪目标有两点原因：
    避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。
    提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。
------------------------------------------------------------------------------------------
如果在一个文件里想要同时生成多个可执行文件，我们可以借助伪目标来实现。使用方式如下：
    .PHONY:all
    all:test1 test2 test3
    test1:test1.o
        gcc -o $@ $^
    test2:test2.o
        gcc -o $@ $^
    test3:test3.o
        gcc -o $@ $^
我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 "all" 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。
之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 "all" 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令make test1 来实现 ）。 
******************************************************************************************
******************************************************************************************
Makefile常用字符串处理函数

1. 模式字符串替换函数，函数使用格式如下：
	$(patsubst <pattern>,<replacement>,<text>)
函数说明: 函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，则用 replacement 替换。
返回值:   替换后的新字符串。
实例: OBJ=$(patsubst %.c,%.o,1.c 2.c 3.c)
	"1.o 2.o 3.o"

2. 字符串替换函数，函数使用格式如下：
	$(subst <from>,<to>,<text>)
函数说明: 函数的功能是把字符串中的 from 替换成 to。
返回值:   替换后的新字符串。
实例: OBJ=$(subst ee,EE,feet on the street)
	"fEEt on the strEEt)"

3. 去空格函数，函数使用格式如下：
	$(strip <string>)
函数说明: 函数的功能是去掉字符串的开头和结尾的字符串，并且将其中的多个连续的空格合并成为一个空格。
返回值:   去掉空格后的字符串。
实例: OBJ=$(strip    a       b c)
	"a b c"

4. 查找字符串函数，函数使用格式如下：
	$(findstring <find>,<in>)
函数说明: 函数的功能是查找  in 中的 find ,如果我们查找的目标字符串存在。
返回值:   目标字符串，如果不存在就返回空。
实例: OBJ=$(findstring a,a b c)
	"a"

5. 过滤函数，函数使用格式如下：
	$(filter <pattern>,<text>)
函数说明: 函数的功能是过滤出 text 中符合模式 pattern 的字符串，可以有多个 pattern 。
返回值:   过滤后的字符串。
实例: OBJ=$(filter %.c %.o,1.c 2.o 3.s)
	"1.c 2.o"

6. 反过滤函数，函数使用格式如下：
	$(filter-out <pattern>,<text>)
函数说明: 函数的功能是功能和 filter 函数正好相反，但是用法相同。去除符合模式  pattern 的字符串，保留符合的字符串。
返回值:   保留的字符串。
实例: OBJ=$(filter-out 1.c 2.o ,1.o 2.c 3.s)
	"3.s"

7. 排序函数，函数使用格式如下：
	$(sort <list>)
函数说明: 函数的功能是将 <list> 中的单词排序（升序）。
返回值:   排列后的字符串。
实例: OBJ=$(sort foo bar foo lost)
	"bar foo lost"

8. 取单词函数，函数使用格式如下：
	$(word <n>,<text>)
函数说明：函数的功能是取出函数 <text> 中的第n个单词。
返回值:  我们取出的第 n 个单词。
实例: OBJ=$(word 2,1.c 2.c 3.c)
	"2.c"
------------------------------------------------------------------------------------------
Makefile常用文件名操作函数

1. 取目录函数，函数使用格式如下：
	$(dir <names>)
函数说明: 函数的功能是从文件名序列 names 中取出目录部分，如果没有 names 中没有 "/" ，取出的值为 "./" 。
返回值:   目录部分，指的是最后一个反斜杠之前的部分。如果没有反斜杠将返回“./”。
实例: OBJ=$(dir src/foo.c hacks)
	"src/ ./"

2. 取文件函数，函数使用格式如下：
	$(notdir <names>)
函数说明: 函数的功能是从文件名序列 names 中取出非目录的部分。非目录的部分是最后一个反斜杠之后的部分。
返回值:   文件非目录的部分。
实例: OBJ=$(notdir src/foo.c hacks)
	"foo.c hacks"

3. 取后缀名函数，函数使用格式如下：
	$(suffix <names>)
函数说明: 函数的功能是从文件名序列中 names 中取出各个文件的后缀名。
返回值:   文件名序列 names 中的后缀序列，如果文件没有后缀名，则返回空字符串。
实例: OBJ=$(suffix src/foo.c hacks)
	".c"

4. 取前缀函数，函数使用格式如下：
	$(basename <names>)
函数说明: 函数的功能是从文件名序列 names 中取出各个文件名的前缀部分。
返回值:   被取出来的文件的前缀名，如果文件没有前缀名则返回空的字符串。
实例: OBJ=$(basename src/foo.c hacks)
	"src/foo hack"

5. 添加后缀名函数，函数使用格式如下：
	$(addsuffix <suffix>,<names>)
函数说明: 函数的功能是把后缀 suffix 加到 names 中的每个单词后面。
返回值:   添加上后缀的文件名序列。
实例: OBJ=$(addsuffix .c,src/foo.c hacks)
	"src/foo.c.c hacks.c"

6. 添加前缀名函数，函数使用格式如下：
	$(addperfix <prefix>,<names>)
函数说明: 函数的功能是把前缀 prefix 加到 names 中的每个单词的前面。
返回值:   添加上前缀的文件名序列。
实例: OBJ=$(addprefix src/, foo.c hacks)
	"src/foo.c src/hacks.c"

7. 链接函数，函数使用格式如下：
	$(join <list1>,<list2>)
函数说明: 函数功能是把 list2 中的单词对应的拼接到 list1 的后面。如果 list1 的单词要比 list2的多，那么，list1 中多出来的单词将保持原样，如果 list1 中的单词要比 list2 中的单词少，那么 list2 中多出来的单词将保持原样。
返回值:   拼接好的字符串。
实例: OBJ=$(join src car,abc zxc qwe)
	"srcabc carzxc qwe"

8. 获取匹配模式文件名函数，命令使用格式如下：
	$(wildcard PATTERN)
函数说明: 函数的功能是列出当前目录下所有符合模式的 PATTERN 格式的文件名。
返回值:   空格分隔并且存在当前目录下的所有符合模式 PATTERN 的文件名。
实例: OBJ=$(wildcard *.c  *.h)
------------------------------------------------------------------------------------------
Makefile中的其它常用函数

1. $(foreach <var>,<list>,<text>)
函数的功能是: 把参数<list>中的单词逐一取出放到参数 <var> 所指定的变量中，然后再执行<text>所包含的表达式。每一次 <text> 会返回一个字符串，循环过程中，<text> 的返所返回的每个字符串会以空格分割，最后当整个循环结束的时候，<text> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以<var>最好是一个变量名，<list> 可以是一个表达式，而<text>中一般会只用 <var>这个参数来一次枚举<list>中的单词。
实例: name:=a b c d
      files:=$(foreach n,$(names),$(n).o)
	"a.o b.o c.o d.o"

2. $(if <condition>,<then-part>)或(if<condition>,<then-part>,<else-part>)
可见，if 函数可以包含else部分，或者是不包含，即if函数的参数可以是两个，也可以是三个。condition参数是 if 表达式，如果其返回的是非空的字符串，那么这个表达式就相当于返回真，于是，then-part就会被计算，否则else-part会被计算。
而if函数的返回值是如果condition为真（非空字符串），那么then-part会是整个函数的返回值。如果condition为假（空字符串），那么else-part将会是这个函数的返回值。此时如果else-part没有被定义，那么整个函数返回空字串符。所以，then-part和else-part只会有一个被计算。
实例: OBJ:=foo.c
      OBJ:=$(if $(OBJ),$(OBJ),main.c)
	"foo.c"

3. $(call <expression>,<parm1>,<parm2>,<parm3>,...)
call 函数是唯一一个可以用来创建新的参数化的函数。我们可以用来写一个非常复杂的表达式，这个表达式中，我们可以定义很多的参数，然后你可以用 call 函数来向这个表达式传递参数。
当 make 执行这个函数的时候，expression参数中的变量$(1)、$(2)、$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是 call 函数的返回值。
实例1: reverse = $(1) $(2)
       foo = $(call reverse,a,b)
	"a b"
实例2: reverse = $(2) $(1)
       foo = $(call reverse,a,b)
	"b a" 

4. $(origin <variable>)
origin 函数不像其他的函数，它并不操作变量的值，它只是告诉你这个变量是哪里来的。 
注意：variable 是变量的名字，不应该是引用，所以最好不要在 variable 中使用“$”字符。origin 函数会员其返回值来告诉你这个变量的“出生情况”。
下面是origin函数返回值：
    “undefined”：如果<variable>从来没有定义过，函数将返回这个值。
    “default”：如果<variable>是一个默认的定义，比如说“CC”这个变量。
    “environment”：如果<variable>是一个环境变量并且当Makefile被执行的时候，“-e”参数没有被打开。
    “file”：如果<variable>这个变量被定义在Makefile中，将会返回这个值。
    “command line”：如果<variable>这个变量是被命令执行的，将会被返回。
    “override”：如果<variable>是被override指示符重新定义的。
    “automatic”：如果<variable>是一个命令运行中的自动化变量。
******************************************************************************************
******************************************************************************************
如果使用 "include" 包含文件的时候，指定的文件不是文件的绝对路径或者是为当前文件下没有这个文件，make 会根据文件名会在以下几个路径中去找，首先我们在执行 make 命令的时候可以加入选项 "-I" 或 "--include-dir" 后面添加上指定的路径，如果文件存在就会被使用，如果文件不存在将会在其他的几个路径中搜索："usr/gnu/include"、"usr/local/include" 和 "usr/include"。

使用时，通常用 "-include" 来代替 "include" 来忽略文件不存在或者是无法创建的错误提示

这两种方式之间的区别：
    使用 "include <filenames>" ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。
    使用 "-include <filenames>"，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。
******************************************************************************************
******************************************************************************************
make 可以使用的参数选项

-b，-m					忽略，提供其他版本 make 的兼容性
-B，--always-make 		强制重建所有的规则目标，不根据规则的依赖描述决定是否重建目标文件。
-C DIR，--directory=DIR 	在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 "-C" 选项的时候，make 的最终工作目录是第一个目录的相对路径。
-d 						make 在执行的过程中打印出所有的调试信息，包括 make 认为那些文件需要重建，那些文件需要比较最后的修改时间、比较的结果，重建目标是用的命令，遗憾规则等等。使用 "-d" 选项我们可以看到 make 构造依赖关系链、重建目标过程中的所有的信息。
--debug[=OPTIONS] 		make 执行时输出调试信息，可以使用 "OPTIONS" 控制调试信息的级别。默认是 "OPTIONS=b" ，"OPTIONS" 的可值为以下这些，首字母有效：all、basic、verbose、implicit、jobs、makefile。
-e，--enveronment
-overrides 				使用环境变量定义覆盖 Makefile 中的同名变量定义。
-f=FILE，--file=FILE，
--makefile=FILE 		指定文件 "FILE" 为 make 执行的 Makefile 文件
-p，--help 				打印帮助信息。
-i，--ignore-errors 		执行过程中忽略规则命令执行的错误。
-I DIR，
--include-dir=DIR 		指定包含 Makefile 文件的搜索目录，在Makefile中出现另一个 "include" 文件时，将在 "DIR" 目录下搜索。多个 "-i" 指定目录时，搜索目录按照指定的顺序进行。
-j [JOBS]
--jobs[=JOBS] 			可指定同时执行的命令数目，爱没有 "-j" 的情况下，执行的命令数目将是系统允许的最大可能数目，存在多个 "-j" 目标时，最后一个目标指定的 JOBS 数有效。
-k，--keep-going 		执行命令错误时不终止 make 的执行，make 尽最大可能执行所有的命令，直至出现致命的错误才终止。
-l load，
--load-average=[=LOAD]，
--max-load[=LOAD] 		告诉 make 在存在其他任务执行的时候，如果系统负荷超过 "LOAD"，不在启动新的任务。如果没有指定 "LOAD" 的参数  "-l" 选项将取消之前 "-l" 指定的限制。
-n，--just-print，
--dry-run 				只打印执行的命令，但是不执行命令。
-o FILE，--old-file=FILE，
--assume-old=FILE 		指定 "FILE"文件不需要重建，即使是它的依赖已经过期；同时不重建此依赖文件的任何目标。注意：此参数不会通过变量 "MAKEFLAGS" 传递给子目录进程。
p，--print-date-base 	命令执行之前，打印出 make 读取的 Makefile 的所有数据，同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 "make -qp" 命令，查看 make 执行之前预设的规则和变量，可使用命令 "make -p -f /dev/null"
-q，-question 			称为 "询问模式" ；不运行任何的命令，并且无输出。make 只返回一个查询状态。返回状态 0 表示没有目标表示重建，返回状态 1 表示存在需要重建的目标，返回状态 2 表示有错误发生。
-r，--no-builtin-rules 	取消所有的内嵌函数的规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时选项 "-r" 会取消所有后缀规则的隐含后缀列表，同样我们可以在 Makefile 中使用 ".SUFFIXES"，定义我们的后缀名的规则。"-r" 选项不会取消 make 内嵌的隐含变量。
-R，
--no-builtin-variabes 	取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意："-R" 和 "-r" 选项同时打开，因为没有了隐含变量，所以隐含规则将失去意义。
-s，--silent，--quiet 	取消命令执行过程中的打印。
-S，--no-keep-going，
--stop 					取消 "-k" 的选项在递归的 make 过程中子 make 通过 "MAKEFLAGS" 变量继承了上层的命令行选项那个。我们可以在子 make 中使用“-S”选项取消上层传递的 "-k" 选项，或者取消系统环境变量 "MAKEFLAGS" 中 "-k"选项。
-t，--touch 				和 Linux 的 touch 命令实现功能相同，更新所有的目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。
-v，version 				查看make的版本信息。
-w，--print-directory 	在 make 进入一个子目录读取 Makefile 之前打印工作目录，这个选项可以帮助我们调试 Makefile，跟踪定位错误。使用 "-C" 选项时默认打开这个选项。
--no-print-directory 	取消 "-w" 选项。可以是 用在递归的 make 调用的过程中 ，取消 "-C" 参数的默认打开 "-w" 的功能。
-W FILE，--what-if=FILE，
--new-file=FILE，
--assume-file=FILE 		设定文件 "FILE" 的时间戳为当前的时间，但不更改文件实际的最后修改时间。此选项主要是为了实现对所有依赖于文件 "FILE" 的目标的强制重建。
--warn-undefined-variables 	在发现 Makefile 中存在没有定义的变量进行引用时给出告警信息。此功能可以帮助我们在调试一个存在多级嵌套变量引用的复杂 Makefile。但是建议在书写的时候尽量避免超过三级以上的变量嵌套引用。
******************************************************************************************
******************************************************************************************
 1. 强制目标
如果一个目标中没有命令或者是依赖，并且它的目标不是一个存在的文件名，在执行此规则时，目标总会被认为是最新的。
    clean:FORCE
        rm $(OBJECTS)
    FORCE:
这个例子中，目标 "FORCE" 符合上边的条件。它作为目标 "clean" 的依赖，在执行 make 的时候，总被认为更新过。因此 "clean" 所在的规则而在被执行其所定义的那个命令总会被执行。这样的一个目标通常我们将其命名为 "FORCE"。
例子中使用 "FORCE" 目标的效果和将 "clean" 声明为伪目标的效果相同。 
------------------------------------------------------------------------------------------
2. 空目标文件
空目标文件是伪目标的一个变种，此目标所在的规则执行的目的和伪目标相同——通过 make 命令行指定将其作为终极目标来执行此规则所定义的命令。和伪目标不同的是：这个目标可以是一个存在的文件，但文件的具体内容我们并不关心，通常此文件是一个空文件。
空目标文件只是用来记录上一次执行的此规则的命令的时间。在这样的规则中，命令部分都会使用 "touch" 在完成所有的命令之后来更新目标文件的时间戳，记录此规则命令的最后执行时间。make 时通过命令行将此目标作为终极目标，当前目标下如果不存在这个文件，"touch" 会在第一次执行时创建一个的文件。
通常，一个空目标文件应该存在一个或者多个依赖文件。将这个目标作为终极目标，在它所依赖的文件比它更新时，此目标所在的规则的命令行将被执行。就是说如果空目标文件的依赖文件被改变之后，空目标文件所在的规则中定义的命令会被执行。
    print:foot.c bar.c
        lpr -p $?
        touch print
执行 "make print" ,当目标文件 "print" 的依赖文件被修改之后，命令 "lpr -p $?" 都会被执行，打印这个被修改的文件。 
------------------------------------------------------------------------------------------
3. 特殊的目标
PHONY: 			这个目标的所有依赖被作为伪目标。伪目标是这样一个目标：当使用 make 命令行指定此目标时，这个目标所在的规则定义的命令、无论目标文件是否存在都会被无条件执行。
.SUFFIXES: 		这个目标的所有依赖指出了一系列在后缀规则中需要检查的后缀名
.DEFAULT: 		Makefile 中，这个特殊目标所在规则定义的命令，被用在重建那些没有具体规则的目标，就是说一个文件作为某个规则的依赖，却不是另外一个规则的目标时，make 程序无法找到重建此文件的规则，这种情况就执行 ".DEFAULT" 所指定的命令。
.PRECIOUS: 		这个特殊目标所在的依赖文件在 make 的过程中会被特殊处理：当命令执行的过程中断时，make 不会删除它们。而且如果目标的依赖文件是中间过程文件，同样这些文件不会被删除。
.INTERMEDIATE: 	这个特殊目标的依赖文件在 make 执行时被作为中间文件对待。没有任何依赖文件的这个目标没有意义。
.SECONDARY: 	这个特殊目标的依赖文件被作为中过程的文件对待。但是这些文件不会被删除。这个目标没有任何依赖文件的含义是：将所有的文件视为中间文件。
.IGNORE 		这个目标的依赖文件忽略创建这个文件所执行命令的错误，给此目标指定命令是没有意义的。当此目标没有依赖文件时，将忽略所有命令执行的错误。
.DELETE_ON_ERROR: 		如果在 Makefile 中存在特殊的目标 ".DELETE_ON_ERROR" ，make 在执行过程中，荣国规则的命令执行错误，将删除已经被修改的目标文件。
.LOW_RESOLUTION_TIME: 	这个目标的依赖文件被 make 认为是低分辨率时间戳文件，给这个目标指定命令是没有意义的。通常的目标都是高分辨率时间戳。
.SILENT: 				出现在此目标 ".SILENT" 的依赖文件列表中的文件，make 在创建这些文件时，不打印出此文件所执行的命令。同样，给目标 "SILENT" 指定命令行是没有意义的。
.EXPORT_ALL_VARIABLES: 	此目标应该作为一个简单的没有依赖的目标，它的功能是将之后的所有变量传递给子 make 进程。
.NOTPARALLEL: 	Makefile 中如果出现这个特殊目标，则所有的命令按照串行的方式执行，即使是存在 make 的命令行参数 "-j" 。但在递归调用的子make进程中，命令行可以并行执行。此目标不应该有依赖文件，所有出现的依赖文件将会被忽略。
------------------------------------------------------------------------------------------
4. 多规则目标
Makefile 中，一个文件可以作为多个规则的目标。这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表，当其中的任何一个依赖文件比目标更新时，make 将会执行特定的命令来重建这个目标。
对于一个多规则的目标，重建这个目标的命令只能出现在一个规则中。如果多个规则同时给出重建此目标的命令，make 将使用最后一个规则中所定义的命令，同时提示错误信息。某些情况，需要对相同的目标使用不同的规则中所定义的命令，我们需要使用另一种方式——双冒号规则来实现。
一个仅仅描述依赖关系的描述规则可以用来给出一个或者时多个目标文件的依赖文件。例如，Makefile 中通常存在一个变量，就像我们以前提到的 "objects" ,它定义为所有的需要编译的生成 .o 文件的列表。这些 .o 文件在其源文件中包含的头文件 "config.h" 发生变化之后能够自动的被重建，我们可以使用多目标的方式来书写 Makefile： 
    objects=foo.o bar.o
    foo.o:defs.h
    bar.o:defs.h test.h
    $(objects):config.h
这样做的好处是：我们可以在源文件增加或者删除了包含的头文件以后不用修改已存在的 Makefile 的规则，只需要增加或者删除某一个 .o 文件依赖的头文件。这种方式很简单也很方便。

我们也可以通过一个变量来增加目标的依赖文件，使用 make 的命令行来指定某一个目标的依赖头文件，例如：
extradeps=
$(objects):$(exteradeps)
它的意思是：如果我们执 "make exteradeps=foo.h" 那么 "foo.h" 将作为所有的 .o 文件的依赖文件。当然如果只执行 "make" 的话，就没有指定任何文件作为 .o 文件的依赖文件。
******************************************************************************************
******************************************************************************************
Makefile控制函数

1. $(error TEXT...)
函数功能：产生致命错误，并提示 "TEXT..." 信息给用户，并退出 make 的执行。需要说明的是："error" 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 "error" 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 "TEXT..." 同时退出 make。
返回值：空
函数说明："error" 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。
ERR=$(error found an error!)
.PHONY:err
err:;$(ERR)
ERROR1=1234
all:
ifdef ERROR1
	$(error error is $(ERROR1))
endif

2. $(warning TEXT...)
函数功能：函数 "warning" 类似于函数 "error" ，区别在于它不会导致致命错误（make不退出），而只是提示 "TEXT..."，make 的执行过程继续。
返回值：空
函数说明：用法和 "error" 类似，展开过程相同。
******************************************************************************************
******************************************************************************************
Makefile中常见的错误信息

make 执行过程中所产生错误并不都是致命的，特别是在命令行之前存在 "-"、或者 make 使用 "-k" 选项执行时。make 执行过程的致命错误都带有前缀字符串 "***"。错误信息都有前缀，一种是执行程序名作为错误前缀（通常是 "make"）；另外一种是当 Makefile 本身存在语法错误无法被 make 解析并执行时，前缀包含了 Makefile 文件名和出现错误的行号。

在下述的错误列表中，省略了普通前缀：

[FOO] Error NN
[FOO] signal description
这类错误并不是 make 的真正错误。它表示 make 检测到 make 所调用的作为执行命令的程序返回一个非零状态（Error NN），或者此命令程序以非正常方式退出（携带某种信号）。
如果错误信息中没有附加 "***" 字符串，则是子过程的调用失败，如果 Makefile 中此命令有前缀 "-"，make 会忽略这个错误。

missing separator. Stop.
missing separator (did you mean TAB instead of 8 spaces?). Stop.
错误的原因：不可识别的命令行，make 在读取 Makefile 过程中不能解析其中包含的内容。GNU make在读取 Makefile 时根据各种分隔符（:, =, [TAB]字符等）来识别 Makefile 的每一行内容。这些错误意味着 make 不能发现一个合法的分隔符。
出现这些错误信息的可能的原因是（或许是编辑器，绝大部分是ms- windows的编辑器）在 Makefile 中的命令之前使用了4个（或者8个）空格代替了 [Tab] 字符。这种情况，将产生上述的第二种形式产生错误信息。且记，所有的命令行都应该是以 [Tab] 字符开始的。

commands commence before first target. Stop.
missing rule before commands. Stop.
Makefile 可能是以命令行开始：以 [Tab] 字符开始，但不是一个合法的命令行（例如，一个变量的赋值）。命令行必须和规则一一对应。
产生第二种的错误的原因可能是一行的第一个非空字符为分号，make 会认为此处遗漏了规则的 "target: prerequisite" 部分。

No rule to make target 'XXX'.
No rule to make target 'XXX ', needed by 'yyy'.
无法为重建目标“XXX”找到合适的规则，包括明确规则和隐含规则。
修正这个错误的方法是：在 Makefile 中添加一个重建目标的规则。其它可能导致这些错误的原因是 Makefile 中文件名拼写错误，或者破坏了源文件树（一个文件不能被重建，可能是由于依赖文件的问题）。

No targets specified and no makefile found. Stop.
No targets. Stop.
第一个错误表示在命令行中没有指定需要重建的目标，并且 make 不能读入任何 Makefile 文件。第二个错误表示能够找到 Makefile 文件，但没有终极目标或者没有在命令行中指出需要重建的目标。这种情况下，make 什么也不做。

Makefile 'XXX' was not found.
Included makefile 'XXX' was not found.
没有使用 "-f" 指定 Makefile 文件，make 不能在当前目录下找到默认 Makefile（makefile 或者 GNUmakefile）。使用 "-f" 指定文件，但不能读取这个指定的 Makefile 文件。

warning: overriding commands for target 'XXX'
warning: ignoring old commands for target 'XXX'
对同一目标 "XXX" 存在一个以上的重建命令。GNU make 规定：当同一个文件作为多个规则的目标时，只能有一个规则定义重建它的命令（双冒号规则除外）。如果为一个目标多次指定了相同或者不同的命令，就会产生第一个告警；第二个告警信息说新指定的命令覆盖了上一次指定的命令。

Circular XXX <- YYY dependency dropped.
规则的依赖关系产生了循环：目标 "XXX" 的依赖文件为 "YYY"，而依赖 "YYY" 的依赖列表中又包含 "XXX"。

Recursive variable 'XXX' references itself (eventually). Stop.
make 的变量 "XXX"（递归展开式）在替换展开时，引用它自身。无论对于直接展开式变量（通过:=定义的）或追加定义（+=），这都是不允许的。

Unterminated variable reference. Stop.
变量或者函数引用语法不正确，没有使用完整的的括号（缺少左括号或者右括号）。

insufficient arguments to function 'XXX'. Stop.
函数 "XXX" 引用时参数数目不正确。函数缺少参数。

missing target pattern. Stop.
multiple target patterns. Stop.
target pattern contains no '%'. Stop.             
mixed implicit and static pattern rules. Stop.
不正确的静态模式规则。
第一条错误的原因是：静态模式规则的目标段中没有模式目标；
第二条错误的原因是：静态模式规则的目标段中存在多个模式目标；
第三条错误的原因是：静态模式规则的目标段目标模式中没有包含模式字符“%”；
第四条错误的原因是：静态模式规则的三部分都包含了模式字符“%”。正确的应该是只有后两个才可以包含模式字符“%”。

warning: -jN forced in submake: disabling jobserver mode.
这一条告警和下条告警信息发生在：make 检测到递归的 make 调用时，可通信的子 make 进程出现并行处理的错误。递归执行的 make 的命令行参数中存在 "-jN" 参数（N的值大于1），在有些情况下可能导致此错误，例如：Makefile 中变量 "MAKE" 被赋值为 "make –j2"，并且递归调用的命令行中使用变量 "MAKE"。在这种情况下，被调用 make 进程不能和其它 make 进程进行通信，其只能简单的独立的并行处理两个任务”。

warning: jobserver unavailable: using -j1. Add '+' to parent make rule.
为了现实 make 进程之间的通信，上层 make 进程将传递信息给子 make 进程。在传递信息过程中可能存在这种情况，子 make 进程不是一个实际的 make 进程，而上层make却不能确定子进程是否是真实的 make 进程。它只是将所有信息传递下去。上层 make 采用正常的算法来决定这些。当出现这种情况，子进程只会接受父进程传递的部分有用的信息。子进程会产生该警告信息，之后按照其内建的顺序方式进行处理。
******************************************************************************************
******************************************************************************************
gcc  （早期是gnu c compiler，现在可以编译多种源代码文件）
现在可以编译c、c++、java...
优点：跨平台
软件平台支持：windows linux Android
硬件平台支持：arm x86 sh4 mips...

gcc hello.c--->默认生成a.out
gcc hello.c -o hello--->生成hello   -o 指定生成的文件名
------------------------------------------------------------------------------------------
gcc编译过程

1.预处理（将c代码 变成.i文件）
gcc -E main.cpp -o main.i
1)头文件copy到源文件中
2)将注释删掉
3)将宏定义用宏值替换宏名，不对语法进行检查
如果include两个相同的头文件且没有其他处理，则会包含两份头文件，所以需要用#ifdef处理

2.编译（将c代码 变成.s文件）
gcc -S main.c   -o main.s

3.汇编（将汇编代码变成目标文件）
gcc -c main.c   -o main.o 
gcc -c main.s   -o main.o 

4.链接（将多个.o文件链接在一起生成一个最终可执行文件）
gcc    main.o   -o  main

-Wall  显示所有警告（建议加）
-w      忽略所有警告（建议不加，但是当有大量警告且只关注error的时候可以加此项以快速寻找error）
------------------------------------------------------------------------------------------
gcc优化
Linux自动是打开gcc优化的
可以使用time ./main 来看main执行的时间
real	0m0.000s
user	0m0.000s
sys	0m0.000s
real是实际执行的时间，user用户程序时间，sys系统函数时间
linux是非实时系统，所以由于系统调度的原因time出来的时间并不是特别准

数越大优化级别越高，linux程序员一般是使用-O2，-O2会对程序在时间效率和空间效率上进行优化
gcc -O1 main.c -o maino1  //-O1 1级优化
gcc -O2 main.c -o maino2  //-O2 2级优化
gcc -O3 main.c -o maino3  //-O3 3级优化
******************************************************************************************
******************************************************************************************
Makefile
------------------------------------------------------------------------------------------
提高编译速度
将每个.c编译成.o然后用.o去生成可执行文件
------------------------------------------------------------------------------------------
变量推荐
OBJS:=...
EXEC:=...
CC:=gcc
CFLAG:= -Wall
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
