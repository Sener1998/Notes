******************************************************************************************
******************************************************************************************
1. 内核编程时既不能访问C库也不能访问标准的C头文件；
2. 内核编程时必须使用GNU C；
3. 内核编程时缺乏像用户空间那样的内存保护机制
4. 内核编程时难以执行浮点运算
5. 内核编程时每个进程只有一个很小的定长堆栈
6. 由于内核支持异步终端、抢占和SMP，因此必须时刻注意同步和并发
7. 要考虑可移植性的重要性
------------------------------------------------------------------------------------------
printk(KERN_ERR "this is an error!\n")
用printk来打印信息，可以使用syslog来查看，或者在/vat/log/里面看
------------------------------------------------------------------------------------------
1. 内联(inline)函数
通常把时间要求比较高却本身又比较短的函数定义成内联函数
定义内联函数的时候需要使用static作为关键字，并且用inline限定它：
static inline void wolf(unsigned long tail_size)
必须在使用前就定义好，否者编辑器就没法展开，事件中一般在头文件中定义内联函数
由于使用static所以编译时不会为内联函数单独建立一个函数体
如果一个内联函数只在某个源文件中使用，那么可以定义在该文件开始的地方
优先使用内联函数而不是复杂的宏

2. 内联汇编
通常使用asm()指令嵌入汇编代码
unsigned int low, high;
asm volatile("rdtsc" : "=a" (low), "=d" (high));
/* low和high分别包含了64位时间戳的低32位和高32位 */
linux内核混合使用C和汇编，在篇体系结构的底层和对时间要求严格的地方一般使用汇编

3. 分支声明
likely() unlikely 如果该条件很少出现就用后者，否则前者
if(unlikely(error){      // error绝大多数时间都会为0
}
if(likely(success){      // success绝大多数时间都会为1
}
unlikely通常使用更多，因为if往往判断特殊情况
------------------------------------------------------------------------------------------
用户程序进行非法内存访问，内核会发现错误，发送SIGSEGV信号，并结束整个进程
内核则没有东西照顾，会直接死掉
内核中的内存都不分页，没用掉一个字节，物理内存就减少一个字节
------------------------------------------------------------------------------------------
不要轻易在内核中使用浮点数
应用程序实现，Linux 中的浮点运算是利用数学库函数实现的，
库函数能够被应用程序链接后调用，不能被内核链接调用。
这些运算是在应用程序中运行的，然后再把结果反馈给系统。
Linux 内核如果一定要进行浮点运算，需要在建立内核时选上 math-emu,使用软件模拟计算浮点运算，
缺点：
1)用户在安装驱动时需要重建内核
2)使得这些应用程序在做浮点运算的时候也使用 math-emu，大大的降低了效率
******************************************************************************************
******************************************************************************************
kobject
1. 申请空间     struct kobject *kobj = kmalloc(sizeof(*kobj), GFP_KERNEL)
2. 判断申请成功 if(!kobj) return -ENOMEM;
3. kobject清空  memset(kobj,0,sizeof(*kobj));
4. 初始化       kobj->kset = my_kset;  kobject_init(kobj,my_ktype);
5. 或者直接一步到位 kobject_create
------------------------------------------------------------------------------------------
struct kref {
	atmomic_t refcount;
}
只有一个字段的结构体是为了便于进行类型检测，
意思就是我们可以对kref写一系列的初始化、设置等操作，这里操作函数里面对这个原子变量进行操作
方便开发者，这样就不必自己对原子变量操作了，直接调用包装好的函数
------------------------------------------------------------------------------------------
sysfs相关的有个叫HAL的东西，有时间去看看
******************************************************************************************
加锁有多种多样，各种锁机制之间的区别主要在于：当锁已经被其他线程持有，因而不可用时的行为表现
一些锁被争用时会简单地执行忙等待，而另一些锁会使当前任务睡眠直到锁可用为止。
锁本身是采用原子操作实现地。
------------------------------------------------------------------------------------------
真并发和伪并发
真并发是多处理器同时执行不同的指令导致的
伪并发是系统调度使不同的进程交叉执行导致的
内核可能造成并发执行的原因：
1. 中断
2. 软中断和tasklet
3. 内核抢占
4. 睡眠及与用户空间的同步
5. 对称多处理器
------------------------------------------------------------------------------------------
加锁不难，难的是辨认出真正需要共享的数据和相应的临界区，
如果代码已经写好了，再在里面找到需要加锁的部分并向其中追加锁是很难的。
大多数内核内核数据结构都需要加锁，如果任何其他什么东西都能看到它，就要锁住，给数据而不是代码加锁
------------------------------------------------------------------------------------------
死锁
ABBA死锁，每个线程都等待别的释放锁，而所有的锁都被只有了
1. 按顺序加锁，嵌套使用锁必须要整以相同的顺序获取锁
2. 防止放生饥饿
3. 不要重复请求同一个锁
4. 设计应力求简单
顺序最重要，每次获取多个锁的顺序必须相同，不可线程1依次获取a、b、c，线程1依次获取c、b
------------------------------------------------------------------------------------------
加锁粒度用来描述加锁保护的数据规模，一个过粗的锁保护大块数据，一个过于精细的锁保护很小的一块数据
一般是这两者之间，通常是设计初期是粗锁，然后往精细的方向优化
******************************************************************************************
******************************************************************************************
linux内核实现的自旋锁不可递归，如果试图获取一个正持有的锁，那么就会一直等待
------------------------------------------------------------------------------------------
自旋锁可以使用在中断处理程序中（此处不能使用信号量，因为他们会导致睡眠），
但要在获取锁前禁止本地中断，就是当前处理器上的中断请求
DEFINE_SPINLOCK(mr_lock);
unsigned long flag;
spin_lock_irqsave(mr_lock);
/* 临界区 */
spin_unlock_irqrestore(&mr_lock,flag);
如果确定加锁前中断是激活的，这是可以用spin_lock_irq和spin_unlock_irq
------------------------------------------------------------------------------------------
读写锁 DEFINE_RWLOCK
------------------------------------------------------------------------------------------
信号量是一种睡眠锁
******************************************************************************************
******************************************************************************************
在4.15内核里，init_timer被移除了。需要换用新的timer_setup接口。
------------------------------------------------------------------------------------------
#if 如果Linux内核版本 < KERNEL_VERSION(4,14,0)
    init_timer(&dev->getIntrTimer);
    dev->getIntrTimer.data = (unsigned long) dev;
    dev->getIntrTimer.function = GetIntrTimerCallback;
    /* ... */
    add_timer(&dev->getIntrTimer);
#else
    timer_setup(&dev->getIntrTimer, GetIntrTimerCallback, 0);
    /* the third argument may include TIMER_* flags */
    /* ... */
#endif
------------------------------------------------------------------------------------------
The callback function的语法修改

#if 如果Linux内核版本 < KERNEL_VERSION(4,14,0)
void GetIntrTimerCallback(unsigned long devAddr)
{
    myDevice *dev = (myDevice *) devAddr;
#else
void GetIntrTimerCallback(struct timer_list *t)
{
    myDevice *dev = from_timer(dev, t, getIntrTimer);
#endif
    /* Do something with "dev" */
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
------------------------------------------------------------------------------------------
