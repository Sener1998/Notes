******************************************************************************************
******************************************************************************************
对于时间复杂度的比较

若A算法的时间复杂度为O(N2),B算法的时间复杂度为O(N)，就可以说B比A吊

但如果都是O(n)，就无法只凭理论推导就说哪个吊
因为即使常数操作的次数可比较，但常数操作的不同时间也不同，就只能实际跑跑看哪个更好了
当拼常数操作的时候了就别瞎逼分析了，直接跑跑看
******************************************************************************************
******************************************************************************************
异或（数学符号⊕、C++的运算符为^）可看作无进位相加

异或的性质：
1. 0^N=N  N^N=0
2. 满足交换律、结合律（用无进位相加来理解更简单一点）
a^b=b^a
(a^b)^c=a^(b^c)
所以只要是一批数异或，你怎么个顺序都行
------------------------------------------------------------------------------------------
使用异或实现两数交换
x = x ^ y;
y = x ^ y;
x = x ^ y;
三行代码下来x和y的值就交换了

解析一下下：
记x = a, y = b
第1次异或
x = x^y = a^b 
y = b
第2次异或
x = a^b
y = x^y = a^b^b = a^0 = a
第3次异或
x = x^y = a^b^a= a^a^b = 0^b = b
y = a
所以三次异或之后x与y的值交换了

不过需要满足一个条件：x和y的内存地址不能相同
原因是上述推导过程中有一点很关键就是每一次只改变x或y
如果两块内存相同，则会将该位置的数据摸成零
推导一下：
第1次异或
x = x^y = a^a = 0
y = x = 0
第2次异或
y = x^y = 111111111...
x = y = 111111111...
第3次异或
x = x^y = 0
y = x = 0
------------------------------------------------------------------------------------------
经典面试题：
1. 一组数里面只有1种数A出现了奇数次，其他都是偶数次，找出A
2. 一组数里面只有2种数A、B出现了奇数次，其他都是偶数次，找出A、B
要求时间复杂度O(N)，（额外）空间复杂度O(1)

解：
1.直接全部异或算出来的就是A
2.直接算出来的是A^B，现在怎么找出来A是什么、B是什么
首先可以知道的是A≠B（废话，A=B的话直接就出现偶数次了）
记eor=A^B≠0，这个eor肯定有至少1位是1，这些是1的位就是能够区别A与B的位
那么再来个eor'把所有数里面这些位（用1个或都用都一样）是1的数异或一下
得到eor'=A或B
再令eor = eor^eor' = B或A
eor和eor'就是所求的两个数

用代码解决的话，其中有个问题是如何快速找到eor的哪几位是1，找1个就行了
这个方法可以找到eor最右边的1
rightOne = eor & (~eor + 1)
原理是将eor取反加1后，最左边的那一堆0都变成了1然后加上1就变成了1后边跟一堆0，这个1会进位
那么eor的最左边的一堆0的上一位的那个1取反后是0，然后接受进位后变成了1，此时不会再往上进位了
所以剩下的都仅进行了取反，eor是1的(~eor + 1)就是0
进行与操作后得到rightOne，
rightOne中只有一位是1，那就是eor与(~eor + 1)唯一都是1的那一位，即最右边那个1
所以可以通过判断(X&rightOne)是否等于0来确定X的那一位是0还是1
******************************************************************************************
******************************************************************************************
排序：
O(N2)
选择排序：每一轮都找到最小的挪到前面
冒泡排序：每一轮都让相邻比较大往后稍稍
插入排序：每一轮都让未排序的那个数放到前面排好序的里面的恰当位置
O(N*logN)
归并排序：左边排好序，右边再排好序，再一起排好序，就排完辣

快速排序（基于荷兰国旗问题理解）
1.0版本：（两部分）假如最后一个数是a，让a与大于等于a的那部分右边那个数交换，就确定了a的位置，再令左半边和右半边来一遍这个过程
2.0版本：（三部分）假如最后一个数是a，让a与等于a的那部分右边那个数交换，就确定了a的位置，再令小于a的那部分和大于a的那部分来一遍这个过程
最差情况1.0和2.0时间复杂度都是O(N2)：原因只有一个，就是每次只打到最边上，如果每次都打在中间则是O(N*logN)
3.0版本：等概率选一个数放最后再按前面方法排序，则最好还是最坏就是概率事件了
求数学期望后得到时间复杂度为O(N*logN)

堆排序（O(N*logN)）
用堆结构实现排序，一个一个加，一个一个弹出来，空间复杂度O(1)
------------------------------------------------------------------------------------------
使用场景
归并排序：有稳定性需求
堆排序：  有空间复杂度要求
快速排序：没有要求就用这个，实验证明最快
******************************************************************************************
******************************************************************************************
二分法常见应用
------------------------------------------------------------------------------------------
找到一组有序数字里大于等于某个数的最左侧的位置问题。

例：122222333344444555555，大于等于3最左侧的位置
与二分查找的区别在于后者最后判断的是中间位置的数是不是要查找的，而该问题最后要的数是右边界
------------------------------------------------------------------------------------------
数组中无序，相邻数一定不相等，找一个局部最小数，时间复杂度要好于O(N)

1.先看位置0和N-1是不是局部最小，有的话直接返回
2.如果都不是，说明0->1是变小的，N-2->N-1是变大的，所以中间必有局部最小
找中间的点，看一下M-1、M、M+1的趋势

二分法的本质核心：如果判断一次能直接砍掉一半就能用二分
******************************************************************************************
******************************************************************************************
master公式（递归的子问题必须等规模才能用这个公式求时间复杂度）
T(N) = a*T(N/b)+O(Nd)

N：为递归问题中母问题的总数据量
b：母问题的每个子问题的数据量占N的几分之1
a：母问题调用了几次子问题
O(Nd)：母问题除了子问题调用之外的程序的时间复杂度

可求得时间复杂度：
若（log以b为底的a）logba < d 则为 O(Nd)（N的d次方）
若（log以b为底的a）logba > d 则为 O(Nlogba)（N的logba次方）
若（log以b为底的a）logba = d 则为 O(Nd*logN)（N的d次方乘logN，默认logN不写底数就是以2为底）

例：
public static int getMax(int[] arr)
{
	return process(arr, 0, arr.length - 1);
}

public static int process(int[] arr, int L, int R)
{
	if(L == R)
	{
		return arr[L];
	}
	int mid = L + ((R - L) >> 1); // 取中点，这么写的好处是防止了L+R超过int上限
	int leftmax = process(arr, L, mid);
	int righttmax = process(arr, mid + 1, R);
	return Math.max(leftmax, righttmax);
}

这个程序中：T(N) = 2*T(N/2)+O(1)
N就是L到R的数据量
a=2（调用了leftmax、righttmax）
b=2（子问题是(L,mid)、(mid+1,R)）
d=0（抛去对子问题的调用就剩下返回和计算mid了，所以是O(1)）
求得时间复杂度为O(logN)
******************************************************************************************
******************************************************************************************
小和问题
在一个数组中，每一个数左边比当前数小的数累加起来，加做这个数组的小和。求一个数组的小和。

例：[1,3,4,2,5]
1左边：没有
3左边：1
4左边：1，3
2左边：1
5左边：1，3，4，2
小和等于1+1+3+1+1+3+4+2=16

换个思路，1右边有4个数比1大，所以小和里有4个1，同理2个3、1个4、1个2，小和为16
下面代码的核心在于排序过程中把小和给求了
class Solution
{
public:
	Solution() = delete;
	static int solve(Vector& arr)
	{
		int res = 0;
		int L = 0, R = arr.size() - 1;
		process(res, arr, L, R);
		return res;
	}
	static void process(int& res, Vector& arr, int L, int R)
	{
		if (L == R) {
			return;
		}
		int M = L + ((R - L) >> 1);
		process(res, arr, L, M);
		process(res, arr, M + 1, R);
		merge(res, arr, L, M, R);
	}
	static void merge(int& res, Vector& arr, int L, int M, int R)
	{
		const int len = R - L + 1;
		int* help = new int[len];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			if (arr[p1] < arr[p2]) {
				res += arr[p1] * (R - p2 + 1);
				help[i++] = arr[p1++];
			} else {
				help[i++] = arr[p2++];
			}
		}
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < len; i++) {
			arr[L + i] = help[i];
		}
		delete[] help;
	}
};
------------------------------------------------------------------------------------------
逆序对问题
在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对。请打印所有逆序对。

例：[3,2,4,5,0]
(3,2)、(3,0)、(2,0)、(4,5)、(5,0)
思路和上面小和是一样的

merge函数作如下更改即可
while (p1 <= M && p2 <= R) {
	if (arr[p1] <= arr[p2]) {
		help[i++] = arr[p1++];
	} else {
		for (int j = p1; j <= M; j++){
			std::cout << "( " << arr[j] << ", " << arr[p2] << " )" << std::endl;
		}
		help[i++] = arr[p2++];
	}
}
******************************************************************************************
******************************************************************************************
荷兰国旗问题
------------------------------------------------------------------------------------------
把arr中的数整理成左边都是小于等于a的，右边都是大于a的
static void Solve(Vector& arr, int a)
{
	for (int p = 0, pc = 0; pc < arr.size(); pc++)
	{
		if (arr[pc] <= a)
			Swap(arr[p++], arr[pc]);
	}
}
------------------------------------------------------------------------------------------
把等于a的和小于等于a的分开，所以共三段：小于a的、等于a的、大于a的
第二种情况pc不变的原因是与arr[pc]交换的arr[pr]是没比较过的，所以不能跳过
static void Solve(Vector& arr, int a)
{
	for (int pl = 0, pr = arr.size() - 1, pc = 0; pc <= pr; )
	{
		if (arr[pc] < a)
			Swap(arr[pl++], arr[pc++]);
		else if (arr[pc] > a)
			Swap(arr[pr--], arr[pc]);
		else
			pc++;
	}
}
******************************************************************************************
******************************************************************************************
快速排序的代码实现，要十分主要数据越界以及中间那段的两边坐标处理
static void Solve(Vector& arr)
{
	QuickSort(arr, 0, arr.size() - 1);
}

static void QuickSort(Vector& arr, const int L, const int R)
{
	if (L >= R)
		return;

	int r = L + rand() % (R - L + 1);
	Swap(arr[r], arr[R]);

	int pl = 0, pr = 0;
	Partition(arr, L, R, pl, pr);
	Swap(arr[R], arr[pr + 1]);
	QuickSort(arr, L, pl - 1);
	QuickSort(arr, pr + 2, R);
}

static void Partition(Vector& arr, const int L, const int R, int& pl, int& pr)
{
	pl = L;
	pr = R - 1;
	int pc = L;
	while (pc <= pr)
	{
		if (arr[pc] < arr[R])
			Swap(arr[pl++], arr[pc++]);
		else if (arr[pc] > arr[R])
			Swap(arr[pr--], arr[pc]);
		else
			pc++;
	}
}
******************************************************************************************
******************************************************************************************
桶排序中的基排序中的代码优化

static void  RadixSort(Vector& arr, const int& digit)
{
	Vector help = Vector(arr.size());	// 辅助数组
	const int& radix = 10;				// 以10为底
	int* count = new int[radix];		// 10个桶
	for (int d = 1; d <= digit; d++)	// 从个位开始
	{
		// 每轮都要初始化count
		memset(count, 0, sizeof(int) * radix);
		for (int i = 0; i < arr.size(); i++)
			count[GetDigit(arr[i], d)]++;
			
		// 将桶改进为前缀和桶，十分牛逼的优化
		for (int i = 1; i < radix; i++)
			count[i] += count[i - 1];
		
		// 牛逼之处
		// 前面是从左往右遍历的arr，这里从右往左先匹配到的放在help的对应位置
		// 放完之后count相应位置会减小，也就是说之后遍历到同一个桶的数时就会放在前面的左边
		// 这就实现了先进桶的先出桶，太牛逼了！！！
		for (int i = arr.size() - 1; i >= 0; i--)
			help[count[GetDigit(arr[i], d)]-- - 1] = arr[i];

		// 最后把help赋给arr，再来一轮
		for (int i = 0; i < arr.size(); i++)
			arr[i] = help[i];
	}
	delete[] count;
}
// 得到num从右数第d位的数字是什么
static int  GetDigit(int num, const int& d)
{
	int res = 0;
	const int& radix = 10;
	for (int i = 0; i < d; i++) {
		res = num % radix;
		num = num / radix;
	}
	return res;
}
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------