******************************************************************************************
******************************************************************************************
去除"To run a command as administrator (user "root"), use "sudo <command>".
        See "man sudo_root" for details."
	touch ~/.sudo_as_admin_successful
******************************************************************************************
******************************************************************************************
 echo -e "\033[31;5m 123 \033[0m"

\033 	代表ESC的ASCII码，
[31;5m	[颜色(红、蓝...);显示模式(加粗、下划线、带底色...)m
\033[0m	结束，之后的显示恢复原状
******************************************************************************************
******************************************************************************************
ln -s     [目标目录]         [软链接地址]   //创建
ln -snf  [新目标目录]      [软链接地址]  //修改
******************************************************************************************
******************************************************************************************
bash

cd + ls
.bashrc
文件末尾加入:
cdls() {  
    cd "${1}" 
    ls;  
}  
alias cd='cdls' 
------------------------------------------------------------------------------------------
zsh

function chpwd() {
    emulate -L zsh
    ls
}
******************************************************************************************
******************************************************************************************
二进制转十六进制文本
hexdump -v -e/'"%02x"' rtthread.bin > rtthread.hex
******************************************************************************************
******************************************************************************************
sed 每6个字符
sed 's/....../&\n/g' test
******************************************************************************************
******************************************************************************************
mkdir -p build
若build不存在则创建build，若存在则什么都不执行
******************************************************************************************
******************************************************************************************
虚拟机的ubuntu借助主机科学上网

步骤：
1. 查询vm8的IPv4的地址                   (默认是192.168.248.1)
这一步有问题，遇到的情况是当主机使用有线网络时使用vm8的地址是没问题的，但是使用无线网络的时候要直接使用无线网卡的IP地址
2. 查询v2RayN的http和sock5的端口  (默认分别是10809、10808)
3.同时将v2RayN设置为允许局域网连接
4. ubuntu中设置代理
5. 浏览器设置为使用用户代理
6. git使用proxy翻墙
    (-------git config --global http.proxy 'http://(IP):(port)------)
    git config --global http.proxy 'http://192.168.248.1:10809' 
    git config --global https.proxy 'http://192.168.248.1:10809'
    把'git@github.com:'改为'https://github.com/'

注意：
1. git config --global --unset http.proxy(https.proxy) 可以取消配置
2. git config --global --list 查看配置信息
******************************************************************************************
******************************************************************************************
虚拟机的Ubuntu的ens33没有IP地址

1.首先检查服务里面的VMware DHCP Service是否开启
2.使用dhclient重新获取IP地址
sudo dhclient ens33
sudo ifconfig ens33
dhclient命令 – 动态获取或释放IP地址

可在脚本中使用该两条指令解决
echo "19980203" | sudo -S dhclient ens33 >>/dev/null 2>&1
ifconfig ens33 >>/dev/null 2>&1
******************************************************************************************
******************************************************************************************
修改开机项
在Startup Applications Preferences中添加或删除
******************************************************************************************
******************************************************************************************
从URL文件
wget -r -np -nH -R index.html ${URL}

-r      下载URL所有文件及其子文件夹，无限递归
-np   不到母文件夹中
-nH   不要将文件保存到主机名文件夹
-R index.html    不下载 index.html 文件

wget http://petalinux.xilinx.com/sswreleases/rel-v2021/downloads/acl-2.2.53.tar.gz
wget -r -np -nH -R index.html http://petalinux.xilinx.com/sswreleases/rel-v2021/aarch64/

-c     可断点续连，继续下载，将之前的下载命令单独加上一个-c即可
-t 0   -t表示重连次数，0表示无线，1表示1次
-e "http_proxy=http://192.168.146.1:10809"   表示下载时使用代理


全局修改wget需要修改/etc/wgetrc
https_proxy = http://192.168.11.114:10809/
http_proxy = http://192.168.11.114:10809/
******************************************************************************************
******************************************************************************************
用 ls /bin/sh -al 命令查看/bin/sh 的解释器
修改默认的sh，可以采用命令
sudo dpkg-reconfigure dash
选no
******************************************************************************************
******************************************************************************************
man用来查看不会的命令或函数的帮助

man ls (默认是1)
man 2 open
man 3 printf

帮助信息被分了类型
1 命令的帮助
2 linux系统库函数的帮助
3 标准c库函数的帮助信息

-f 查看帮助类型有哪些
man -f fopen
******************************************************************************************
******************************************************************************************
ps aux 列出所有进程 我一般用ps aux | grep sener，因为我只对我的程序感兴趣

kill   -9  [PID]      强制杀死[PID]进程，如果不加-9可能杀不死，我一般是先不加，如果发现杀不死再加
pkill -9 [NAME]  强制杀死[NAME]进程，-9同上
例子
sener      3434  4.0  0.0  35668  6120 ?        Ssl  10:46   0:00 ./nrc.out
sener      3437  0.0  0.0  16128  1332 ?        S    10:46   0:00 ./nrc.out
对于nrc.out程序，他有两个进程分别是3434和3437，
如果用kill则可能要杀两次，如果杀死第一个线程后另一个线程就关了，就只需杀一次
kill -9 3434
kill -9 3437  （如有必要，一般一次就杀完了）
如果用pkill，则需执行程序名字，会直接杀死该程序的所有进程
pkil -9 nrc.out
在脚本编写的时候若需要杀死某一个进程则一般使用pkill，因为程序进程的PID一般是随机给的，所以使用kill则需要先获取进程的PID在按照PID杀死，但是程序的名字一般我们是知道的，所以直接pkill

init进程（pid 1）是系统启动的第一个进程，之后再创建其他进程
******************************************************************************************
******************************************************************************************
递归删除  特定文件

find /tmp/98/upload -name *.avi -type f -print -exec rm -rf {} \;
find . -name abc -type d -print -exec rm -rf {} \;

(1) "."    表示从当前目录开始递归查找
(2) “ -name '*.exe' "根据名称来查找，要查找所有以.exe结尾的文件夹或者文件
(3) " -type f "查找的类型为文件
(4) "-print" 输出查找的文件目录名
(5) 最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号
------------------------------------------------------------------------------------------
windows里面使用del
del  *index.*  /s
删除当前文件夹及子文件夹里满足*index.*的文件
/s 表示递归删除
******************************************************************************************
******************************************************************************************
安装zsh
首先下载 gitee 镜像的安装脚本

wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh

找到以下部分

# Default settings
ZSH=${ZSH:-~/.oh-my-zsh}
REPO=${REPO:-ohmyzsh/ohmyzsh}
REMOTE=${REMOTE:-https://github.com/${REPO}.git}
BRANCH=${BRANCH:-master}

把

REPO=${REPO:-ohmyzsh/ohmyzsh}
REMOTE=${REMOTE:-https://github.com/${REPO}.git}

替换为

REPO=${REPO:-mirrors/oh-my-zsh}
REMOTE=${REMOTE:-https://gitee.com/${REPO}.git}

保存后直接运行安装脚本
接下来修改仓库地址，这一步是为了更新检查正常

cd ~/.oh-my-zsh
git remote set-url origin https://gitee.com/mirrors/oh-my-zsh.git
git pull

但其实直接下载后运行install.sh就行
------------------------------------------------------------------------------------------
chsh -s /usr/bin/zsh
reboot
******************************************************************************************
******************************************************************************************
git 大神教程
https://zhuanlan.zhihu.com/p/30044692
******************************************************************************************
******************************************************************************************
使用igh 实现EtherCAT主站
------------------------------------------------------------------------------------------
前戏   注意README里面是有问题的
git clone https://gitlab.com/etherlab.org/ethercat.git
git checkout stable-1.5

./bootstrap
去掉额外的加补丁的驱动，使用默认驱动，其实主要是8139too，这个需要实时补丁的支持，内核打了实时补丁就不用去掉
./configure --enable-generic --disable-e100 --disable-8139too --disable-e1000 --disable-r8169
或者
./configure --enable-8139too=no --enable-wildcards=yes （最后用的这个，但这两个应该都行）

sudo make
sudo make modules
sudo make install
sudo make modules_install
sudo depmod 检查依赖关系

{PREFIX}默认是/usr/local，在配置的时候可以改成其他的地方，但是没必要
ln -s ${PREFIX}/etc/init.d/ethercat /etc/init.d/ethercat
cp ${PREFIX}/etc/sysconfig/ethercat /etc/sysconfig/ethercat
修改配置文件
在MASTER0_DEVICE=""填写以太网卡的MAC地址，DEVICE_MODULES="generic"
vim /etc/sysconfig/ethercat
或者先修改再复制
------------------------------------------------------------------------------------------
******************************************************************************************
******************************************************************************************
1. 记录日志但不输出显示：
把 ls 命令的执行结果记录到文件 ls.log 中如果文件已存在，则清空并写入当前的日志信息
ls > test.log

2. 记录日志但不输出显示（末尾追加）：
把 ls 命令的执行结果记录到文件 ls.log 中如果文件已存在，则在末尾追加日志信息
ls >> test.log

3. 即输出显示又记录：
在终端上显示 ls 命令的执行结果并把执行结果输出到 test.log 文件中
ls | tee test.log

4. 即输出显示又记录（末尾追加）：
描述：把 ls 命令的执行结果追加到 test.log 文件的后面
ls | tee -a test.log
******************************************************************************************
******************************************************************************************
硬盘克隆/系统备份/linux密码破解
------------------------------------------------------------------------------------------
1. windows/DOS
使用ghost最方便，推荐使用rufus往u盘里写入FreeDOS(软件自带)，然后把ghost.exe(16位)复制到u盘，然后u盘启动，运行ghost即可
使用过MS-DOS7.1+ghost.exe，但是无法在实际的机器上运行ghost，还是FreeDOS好用
如果只是想玩DOS系统的话还是推荐虚拟机装MS-DOS7.1，因为支持鼠标操作
(不排除我的MSDOS有问题且FreeDOS版本合适的可能性，我是用的rufus 3.8自带的FreeDOS)
------------------------------------------------------------------------------------------
2. linux
不推荐使用ghost，因为在克隆后引导会出错，可能是我的ghost的版本很低，但不重要，因为有更牛逼的方法

2.1首先将u盘制成可以运行ubuntu，最简单的方法是将安装ubuntu的iso写入u盘，然后u盘启动进行try ubuntu模式
如果不想把整个硬盘克隆出来(带引导文件)，只想复制出来一部分文件，则直接在这一步把文件拷出来
2.2执行fdisk指令查看硬盘信息(该模式下，sudo直接用，不需要密码)
sudo fdisk -u -l
2.3(可选)将额外的存储器挂载到/mnt，由于u盘比较小，可能无法存储克隆出的镜像文件
sudo mkdir /mnt/usb
sudo mount /dev/sdb2  /mnt/usb/  (/dev/sdb2为另外一个u盘的第二个分区)
2.4执行dd指令将硬盘的数据打包复制出来
sudo dd ps=512 count=62531584 if=/dev/sda of=/mnt/usb/data.img  (以克隆/dev/sda硬盘为例)
ps=512                 表示512k为1个block的尺寸
count=62531584 表示复制62531584个block这个数量的计算方法是，将fdisk步骤中需要克隆的硬盘的end最后一位的值加1
在这一步会有问题，因为直接生成img文件的话，它是和硬盘总大小相同的，所以对于比较大容量但是实际数据较少的硬盘直接生成img文件太亏
所以可以在克隆过程中可以同时进行压缩
sudo dd ps=512 count=62531584 if=/dev/sda | gzip -6 > /mnt/usb/data.img.gz
gzip 使用压缩指令，默认是6级压缩，有1~9共9个等级，等级越高压缩效果越好但压缩时间越长
解压是使用gzip -d data.img.gz，不过使用这个指令的话，源文件会直接被删掉，也可以使用tar -xzvf，其中的-z就是调用gzip

到此硬盘克隆完毕，接下来“破解”ubuntu
2.5使用StarWind V2V Converter将img文件转成vmdk(vmware的虚拟磁盘文件)
2.6新建一个ubuntu的虚拟机，或者找一个现有的虚拟机插上虚拟磁盘
在编辑虚拟机里面添加硬盘，选择虚拟磁盘选项
如果启动时卡在Switched to clocksource tsc随后进入initramfs状态那么添加硬盘是选择IDE类型，不要使用推荐的SCSI
如果启动时出现Waiting for network configuration并且有长时间的等待，如果不需要，则在修改/etc/init/failsafe.conf
将第一个sleep 20 改成sleep 5，后面的都注释掉
2.7破解密码
不要直接进入ubuntu，而是进入Advanced Options for Ubuntu，找到带recovery mode的选型，按e键进入参数设置页面
删掉recovery nomodeset，再在该行最后添加quiet splash rw init=/bin/bash，最后按F10启动，输入passwd改密码
/etc/passwd文件里面有所有用户的信息
/etc/shadow文件里面存储密码
但是都不重要，在root模式下，可以随意改用户的密码
******************************************************************************************
******************************************************************************************
sudo chvt 1 进入tty1 
sudo chvt 2 进入tty2
...
sudo chvt 7 进入图形化GUI  （Ubuntu）
******************************************************************************************
******************************************************************************************
绿豆沙色能有效的减轻长时间用电脑的用眼疲劳！
色调：85，饱和度：123，亮度：205；
RGB颜色红：199，绿：237，蓝：204；
十六进制颜色：#C7EDCC或用#CCE8CF

其他几种电脑窗口视力保护色：
银河白 #FFFFFF RGB(255, 255, 255)
杏仁黄 #FAF9DE RGB(250, 249, 222)
秋叶褐 #FFF2E2 RGB(255, 242, 226)
胭脂红 #FDE6E0 RGB(253, 230, 224)
青草绿 #E3EDCD RGB(227, 237, 205)
海天蓝 #DCE2F1 RGB(220, 226, 241)
葛巾紫 #E9EBFE RGB(233, 235, 254)
极光灰 #EAEAEF RGB(234, 234, 239)
******************************************************************************************
******************************************************************************************
sudo apt-get install rt-tests 

安装这个工具，运行cyclictest程序进行实时性测试：
    sudo cyclictest -t 5 -p 80 -n 
    注释： 运行五个线程，线程优先级为80，无限循环

cyclictest运行结果详解
    T: 0     序号为0的线程
    P: 0     线程优先级为0
    C: 9397  计数器。线程的时间间隔每达到一次，计数器加1
    I: 1000  时间间隔为1000微秒(us)
    Min:     最小延时(us)
    Act:     最近一次的延时(us)
    Avg：    平均延时(us)
    Max：    最大延时(us)   
------------------------------------------------------------------------------------------
测试结果示例：
1.实体机测试结果
    # /dev/cpu_dma_latency set to 0us
    policy: fifo: loadavg: 0.13 0.06 0.02 1/244 19255
    T: 0 (18989) P:80 I:1000 C: 155947 Min:      1 Act:    1 Avg:    1 Max:      17
    T: 1 (18990) P:80 I:1500 C: 103964 Min:      1 Act:    1 Avg:    1 Max:      15
    T: 2 (18991) P:80 I:2000 C:  77973 Min:      1 Act:    1 Avg:    1 Max:       7
    T: 3 (18992) P:80 I:2500 C:  62378 Min:      1 Act:    1 Avg:    1 Max:      10
    T: 4 (18993) P:80 I:3000 C:  51982 Min:      1 Act:    1 Avg:    1 Max:       7

2.虚拟机测试结果 
在虚拟机中效果一般，受主机的限制太大。
my@ubuntu:~/rt/linux-4.4.138$ sudo cyclictest -p 80 -t5 -n 
# /dev/cpu_dma_latency set to 0us
policy: fifo: loadavg: 0.69 0.19 0.07 1/726 5825          
T: 0 ( 5821) P:80 I:1000 C:   8168 Min:      7 Act:  445 Avg:  327 Max:    7005
T: 1 ( 5822) P:80 I:1500 C:   5455 Min:      7 Act:  411 Avg:  319 Max:    7516
T: 2 ( 5823) P:80 I:2000 C:   4098 Min:     14 Act:  174 Avg:  320 Max:    2362
T: 3 ( 5824) P:80 I:2500 C:   3275 Min:      5 Act:   52 Avg:  319 Max:    6940
T: 4 ( 5825) P:80 I:3000 C:   2732 Min:      8 Act:  214 Avg:  299 Max:    5198

3.也可以进行多次运行并统计结果
sudo  cyclictest -l10000000 -m -n -t1 -p99 -i2000 -h100
-l10000000 ：指定1千万循环，
-m ：锁定当前和将来的内存分配，
-n ：指定使用 clock_nanosleep，
-t1 ：指定开一个线程进行测试，
-p99 ：指定最高优先级，
-i2000 ：指定基本线程间隔,单位是us，
-h100 ：指定统计结果的分布情况。
程序执行结束后，输出显示平均延时1 us，最大延时15 us，通过直方分布图察看，大多集中在1-7 us以内。
******************************************************************************************
******************************************************************************************
linux内核打实施补丁+ubuntu换linux内核

1. 首先确定Linux内核版本，preempt_rt补丁的版本要与Linux内核版本严格一致
以linux-5.4.161和patch-5.4.161-rt67-rc1.patch为例进行操作
理由是我的ubuntu内核版本是5.3的，而5.3的内核是没有相应实时补丁的，就找了个比较近的

2. 打补丁，把补丁文件移动至内核文件夹中
patch -p1 < patch-5.4.161-rt67-rc1.patch

3. 配置Linux内核
make manuconfig
开启实时功能，勾选下面功能
General setup -> Preemption Model (Fully Preemptible Kernel (Real-Time)) 
-> Fully Preemptible Kernel (Real-Time)

4. 编译内核+安装内核
编译内核前安装libssl-dev 
sudo apt-get install libssl-dev
sudo aptitude   install libssl-dev (或)
make -j4

5. 更新gurb
sudo update-grub

6. 重启
这一步比较有意思
需要进入grub选择内核进入，也可能默认就是新的内核，如果要手动切换则需进行其他操作
1)  修改默认启动内核
首先去/boot/grub/grub.cfg看一下grub里面的内核顺序
这个文件是/etc/grub.d和/etc/default/grub自动生成的，仅用于查看信息
找到submanu，下面按照顺序排列了各个内核，从0开始
修改/etc/default/grub
GRUB_DEFAULT=0
2）在grub界面手动选择
需要修改grub界面等待时间
GRUB_TIMEOUT_STYLE=hidden
GRUB_TIMEOUT=0
改成
#GRUB_TIMEOUT_STYLE=hidden
GRUB_TIMEOUT=5
修改完后需要重新更新grub
sudo update-grub
******************************************************************************************
******************************************************************************************
 shell中的if语句

1、基本语法:
if [ command ]; then
     符合该条件执行的语句
fi

2、扩展语法：
if [ command ];then
     符合该条件执行的语句
elif [ command ];then
     符合该条件执行的语句
else
     符合该条件执行的语句
fi

3、语法说明：
      bash shell会按顺序执行if语句，如果command执行后且它的返回状态是0，则会执行符合该条件执行的语句，否则后面的命令不执行，跳到下一条命令。
当有多个嵌套时，只有第一个返回0退出状态的命令会导致符合该条件执行的语句部分被执行,如果所有的语句的执行状态都不为0，则执行else中语句。
返回状态：最后一个命令的退出状态，或者当没有条件是真的话为0。

注意：
1、[ ]表示条件测试。注意这里的空格很重要。要注意在'['后面和']'前面都必须要有空格
2、在shell中，then和fi是分开的语句。如果要在同一行里面输入，则需要用分号将他们隔开。
3、注意if判断中对于变量的处理，需要加引号，以免一些不必要的错误。没有加双引号会在一些含空格等的字符串变量判断的时候产生错误。比如[ -n "$var" ]如果var为空会出错
4、判断是不支持浮点值的
5、如果只单独使用>或者<号，系统会认为是输出或者输入重定向，虽然结果显示正确，但是其实是错误的，因此要对这些符号进行转意
6、在默认中，运行if语句中的命令所产生的错误信息仍然出现在脚本的输出结果中
7、使用-z或者-n来检查长度的时候，没有定义的变量也为0
8、空变量和没有初始化的变量可能会对shell脚本测试产生灾难性的影响，因此在不确定变量的内容的时候，在测试号前使用-n或者-z测试一下
9、? 变量包含了之前执行命令的退出状态（最近完成的前台进程）（可以用于检测退出状态）

常用参数：
文件/目录判断：
常用的：
[ -a FILE ] 如果 FILE 存在则为真。
[ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。
[ -e FILE ] 如果 指定的文件或目录存在时返回为真。
[ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。
[ -r FILE ] 如果 FILE 存在且是可读的则返回为真。
[ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的）
[ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。

不常用的：
[ -b FILE ] 如果 FILE 存在且是一个块文件则返回为真。
[ -c FILE ] 如果 FILE 存在且是一个字符文件则返回为真。
[ -g FILE ] 如果 FILE 存在且设置了SGID则返回为真。
[ -h FILE ] 如果 FILE 存在且是一个符号符号链接文件则返回为真。（该选项在一些老系统上无效）
[ -k FILE ] 如果 FILE 存在且已经设置了冒险位则返回为真。
[ -p FILE ] 如果 FILE 存并且是命令管道时返回为真。
[ -s FILE ] 如果 FILE 存在且大小非0时为真则返回为真。
[ -u FILE ] 如果 FILE 存在且设置了SUID位时返回为真。
[ -O FILE ] 如果 FILE 存在且属有效用户ID则返回为真。
[ -G FILE ] 如果 FILE 存在且默认组为当前组则返回为真。（只检查系统默认组）
[ -L FILE ] 如果 FILE 存在且是一个符号连接则返回为真。
[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则返回为真。
[ -S FILE ] 如果 FILE 存在且是一个套接字则返回为真。
[ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新, 或者 FILE1 存在但是 FILE2 不存在则返回为真。
[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 老, 或者 FILE2 存在但是 FILE1 不存在则返回为真。
[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则返回为真。

字符串判断
[ -z STRING ] 如果STRING的长度为零则返回为真，即空是真
[ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真
[ STRING1 ]　 如果字符串不为空则返回为真,与-n类似
[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真
[ STRING1 != STRING2 ] 如果字符串不相同则返回为真
[ STRING1 < STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。
[ STRING1 > STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。

数值判断
[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,<>
[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,>
[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,>=
[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,<
[ INT1 -le INT2 ] INT1小于等于INT2返回为真,<=

逻辑判断
[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
[ ] || [ ] 用OR来合并两个条件
[ ] && [ ] 用AND来合并两个条件

其他判断
[ -t FD ] 如果文件描述符 FD （默认值为1）打开且指向一个终端则返回为真
[ -o optionname ] 如果shell选项optionname开启则返回为真

IF高级特性：
双圆括号(( ))：表示数学表达式
在判断命令中只允许在比较中进行简单的算术操作，而双圆括号提供更多的数学符号，而且在双圆括号里面的'>','<'号不需要转意。

双方括号[[ ]]：表示高级字符串处理函数
双方括号中判断命令使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。

双括号的作用：
在shell中，[ $a != 1 || $b = 2 ]是不允许出，要用[ $a != 1 ] || [ $b = 2 ]，而双括号就可以解决这个问题的，[[ $a != 1 || $b = 2 ]]。又比如这个[ "$a" -lt "$b" ]，也可以改成双括号的形式(("$a"
 < "$b"))
******************************************************************************************
******************************************************************************************
2>/dev/null

https://www.zhihu.com/question/53295083
知乎回答2022年1月10日

解释很全
******************************************************************************************
******************************************************************************************
数据同步写入磁盘：sync

在Linux系统中，为了加快数据的读取速度，所以在默认的情况中， 某些已经加载内存中的数据将不会直接被写回硬盘，而是先缓存在内存当中，如此一来， 如果一个数据被你重复的改写，那么由于他尚未被写入硬盘中，因此可以直接由内存当中读取出来， 在速度上一定是快上相当多的！

不过，如此一来也造成些许的困扰，那就是万一你的系统因为某些特殊情况造成不正常关机 (例如停电或者是不小心踢到power)时，由于数据尚未被写入硬盘当中，哇！所以就会造成数据的升级不正常啦！ 那要怎么办呢？这个时候就需要sync这个命令来进行数据的写入动作啦！ 直接在文字接口下输入sync，那么在内存中尚未被升级的数据，就会被写入硬盘中！所以，这个命令在系统关机或重新启动之前， 很重要喔！最好多运行几次(2-4次)！

虽然目前的 shutdown/reboot/halt 等等命令均已经在关机前进行了 sync 这个工具的呼叫， 不过，多做几次总是比较放心点～呵呵～

    [root@hotapply home]# sync

    [root@hotapply home]# sync

sync命令 linux同步数据命令

格式： sync　

用途:更新 i-node 表，并将缓冲文件写到硬盘中。

功能：sync命令是在关闭Linux系统时使用的。 用户需要注意的是，不能用简单的关闭电源的方法关闭系统，因为Linux象其他Unix系统一样，在内存中缓存了许多数据，在关闭系统时需要进行内存数据与硬盘数据的同步校验，保证硬盘数据在关闭系统时是最新的，只有这样才能确保数据不会丢失。一般正常的关闭系统的过程是自动进行这些工作的，在系统运行过程中也会定时做这些工作，不需要用户干预。 sync命令是强制把内存中的数据写回硬盘，以免数据的丢失。用户可以在需要的时候使用此命令。

sync 命令运行 sync 子例程。如果必须停止系统，则运行 sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件。
******************************************************************************************
******************************************************************************************
linux split 命令
功能说明：切割文件。

语法：
split [–help][–version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名]
补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。

参数：
-<行数>或-l<行数> 　指定每多少行就要切成一个小文件。
-b<字节> 　指定每多少字就要切成一个小文件。支持单位:m,k
-C<字节> 　与-b参数类似，但切割时尽量维持每行的完整性。
–help 　显示帮助。
–version 　显示版本信息。
[输出文件名] 　设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。

使用例子：
split -b 100m 1111.log (按照字节分隔)
split -l 1000000 1111.log(按照行数分隔)
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************
******************************************************************************************